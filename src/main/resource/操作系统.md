信号量: mutex,初始值为1
在临界区之前实施P(mutex) 减一
在临界区之后实施V(mutex) 加一

管程Monitor: 一种同步机制
    进程只能通过调用管程中的过程来间接地访问管程中的数据结构!
    不适用于多处理器情况
    互斥:
        管程是互斥进入的!
        管程的互斥性是由编译机负责保证的!
    同步:
        管程中设置条件变量以及等待/唤醒操作以解决同步问题!
        可以让一个进程或线程在条件变量上等待,也可以通过发送信号将等待在条件变量上的进程或线程唤醒!
    wait/signal 进程之间的通讯
    wait(c):
        如果紧急等待队列非空,则唤醒第一个等待者;否则释放管程的互斥权,执行此操作的进程进入c链末尾!
    使用notify注意问题:
        notify结果: 位于条件队列头的进程在将来合适的时候且当处理器可用时恢复执行.
        由于不能保证在它之前  没有其他进程进入管程,因而这个进程必须重新检查条件.
    broadcast: 使所有在该条件上等待的进程都被释放并进入就绪队列.
Pthread:
    Pthread_mutex_init
    Pthread_mutex_destory
    Pthread_mutex_lock
    Pthread_mutex_trylock
    Pthread_mutex_unlock
    Pthread_cond_init
    Pthread_cond_destory
    Pthread_cond_wait
    Pthread_cond_signal
    Pthread_cond_broadcast

进程之间通信:
    共享内存
    PIPE
Linux:
    管道,消息队列,共享内存,信号量,信号,套接字
    内核同步机制: 原子操作,自旋锁,读写锁,信号量,屏障...

内核地址空间
用户地址空间
    两者都包含: 代码段,数据段,堆,栈
地址重定位:
    逻辑地址: 相对地址,虚拟地址
        用户程序经过编译,汇编后形成目标代码,目标代码通常采用相对地址的形式,其首地址为0,其余地址都相对于首地址而编址.
        不能用逻辑地址在内存中读取信息.
    物理地址: 绝对地址,实地址
        内存中存储单元的地址,可直接寻址!
    为了保证CPU执行指令时可正确访问内存单元,需要将用户程序中的逻辑地址转换为运行时可由机器直接寻址的物理地址,
    这一过程称为地址重定向.
静态重定位:
    当用户程序加载到内存时,一次性实现逻辑地址到物理地址的转换!
    优点: 程序可直接执行!
    缺点: 不能随意改变逻辑地址,否则需要重新转换!
    一般可以由软件完成.
动态重定位:
    在进程执行过程中进行地址转换,即逐条指令执行时完成地址转换!
    需要硬件部件支持.
重定位寄存器: 可能是用来保存该进程在物理内存中的基址地址(起始地址)
内存管理单元(MMU): memory management unit,用来将逻辑地址转换为物理地址

空闲内存管理:
    等长划分/不等长划分
    数据结构:
        位图: 每个分配单元对应于位图中的一位,比如0代表空闲,1表示占用
        空闲区表,已分配区表            
        空闲块链表
内存分配算法:
    1.首次适配 first fit
        在空闲区表中找到第一个满足进程要求的空闲区
    2.下次适配 next fit
        从上次找到的空闲区处接着查找
    3.最佳适配 best fit
        查找整个空闲区表,找到能够满足进程要求的最小空闲区
    4.最差适配worst fit
        总是分配满足进程要求的最大空闲区.
        将该空闲区分为2部分,一部分为进程使用,另一部分形成一个新的空闲区
伙伴系统:
    一种经典的内存分配方案. linux底层内存管理采用,一种特殊的分离适配算法.
    主要思想:
        将内存按2的幂进行划分,组成若干空闲块链表.查找该链表总能找到满足进程需要的最佳匹配快.
    算法:(可用认为是二分法)
        1.首先将整个可用空间看作一块: 2^U(2的U幂次方)
        2.假设进程申请的空间大小为s,如果满足2^(U-1) < s <= 2^U,则分配整个块;
          否则,将块划分为两个大小相等的伙伴,大小为2^(U-1)
        3.一直划分下去直到产生大于或等于s的最小快.
基本内存管理方案:
    整个进程进入内存中一片连续区域. 这是1,2,3的特性
    1.单一连续区
        一段时间内只有一个进程在内存,简单,内存利用率低.

    2.固定分区
        2.1 把内存空间分割成若干区域,称为分区
        2.2 每个分区的大小可以相同也可以不同
        2.3 分区大小固定不变
        2.4 每个分区装一个且只能装一个进程
    3.可变分区
        3.1 根据进程的需要,把内存空闲空间分割出一个分区,分配给该进程
        3.2 剩余的部分称为新的空闲区
        问题: 外碎片,导致内存利用率下降
        紧缩技术/压缩技术: 移动程序,将所有小的空闲区合并为较大的空闲区,出现新的问题:开销,移动时机
    一个进程进入内存中若干个不连续区域. 这是4,5,6的特性
    4.页式
        设计思想:
            1.用户进程地址空间(虚拟地址)被划分为大小相等的部分,称为页(page)或页面,从0开始编号.
            2.内存空间(物理地址)按照同样大小划分为大小相等的区域,称为页框(page frame)/物理页面/页帧/内存块,从0开始编号;
        内存分配:
            以页为单位进行分配,并按进程需要的页数来分配;逻辑上相邻的页,物理上不一定相邻.
        典型页面尺寸: 4K或者4M,一般为2的幂次方.
        逻辑地址: 页号 + 页内地址(偏移地址)
                    -----------------------
                    |   页号  |  页内地址  |
                    |---------------------|  
        页表:
            虚拟地址和物理地址是通过页表来进行关联映射的,页表中的一项称为页表项;
            页表项: 记录了逻辑页号与页框号的对应关系;
            每个进程有一个页表,存放在内存;
            页表的首个地址存放在页表基址寄存器中(page table base register)
        地址转换(硬件支持)
            CPU取到逻辑地址,自动划分为页号和页内地址,用户页号查询页表的到页框号,再与页内偏移拼接成为物理地址.
        问题:内部碎片
    5.段式
        设计思想:
            1.用户进程地址空间: 按程序自身的逻辑关系划分为若干个程序段,每个程序段都有一个段名.
            2.内存空间被动态划分为若干个长度不相同的区域,成为物理段,每个物理段由起始地址和长度确定.
            内存分配(规则): 以段位单位进行分配,每段在内存中占据连续空间,但各段之间可以不相邻.
        逻辑地址: 段号 + 段内地址 (不是自动划分,必须显示给出)
            -----------------------
            |   段号  |  段内地址  |
            |---------------------|
        段表: 记录逻辑段号与物理内存的映射关系
            1.每项记录了段号,段首地址和段长度之间的关系;
            2.每个进程一个段表,存在在内存
            3.段表其实地址保存在段表基础寄存器
        地址转换(硬件)
            CPU取到逻辑地址,用段号查段表,得到该段在内存的起始地址,与段内地址计算得出物理地址!
    6.段页式
        产生背景:
            综合页式,段式的优点,克服两者的缺点.
        设计思想:
            用户进程划分,先按段划分,每一段再按页面划分
        逻辑地址:
            ------------------------------------
            |     段      |________段内地址______|
            |     号      |   页号   | 页内地址  |
            -------------------------------------
        内存划分: 以页式存储管理方案
        内存分配: 以页为单位进行分配
        数据结构及有关操作:
            段表: 记录了每一段的页表起址和页表长度
            页表: 记录了逻辑页号与页框号的对应关系
            每一段有一张页表,一个进程有多少页表
        空闲区管理: 同页式管理
        内存分配/回收: 同页式管理
内存"扩充"技术:
    1.内存紧缩技术(如可变分区)
    2.覆盖技术 overlaying
        解决问题: 程序大小超过物理内存总和
        按照自身的逻辑结构,将那些不会同事执行的程序段共享同一块内存区域.
        程序员声明覆盖结构,操作系统完成自动覆盖.
        已过时!
    3.交换技术 swapping(重点)
        设计思想: 内存空间紧张时,系统将内存中某些进程暂时移到外存,把外存中某些进程换进内存,占据前者所占用的区域.
                  进程在内存与磁盘之间的动态调度.
        交换的对象: 运行时创建或修改的内容,栈和堆
        交换区: 一般系统会指定一块特殊的磁盘区域作为交换空间(swap space),包含连续的磁道,操作系统可以使用底层
            的磁盘读写操作对其高效的访问.
        栈和队堆: 相对增长 堆数据->空闲区域<-栈数据
    4.虚拟存储技术 virtual memory
        所谓虚拟存储技术是指: 当进程运行时,先将其一部分装入内存,另一部分暂留在磁盘,当要执行的指令或访问的数据不在
    内存时,由操作系统自动完成将他们从磁盘调入内存的工作.
        虚拟地址空间: 即为分配给进程的虚拟内存
        虚拟地址: 在虚拟内存中指令或数据的位置,该位置可以被访问,仿佛它是内存的一部分.
        存储器的层次结构:
                    -寄存器-
              --高速缓存(cache L1)--
             ---高速缓存(cache L2)---
            ----高速缓存(cache L3)----
           ------------内存------------
          -------------磁盘--------------
            特点: 自下而上速度越来越快,自上而下空间越来越大
        地址保护:
            1.确保每个进程有独立的地址空间.
            2.确保进程访问合法的地址范围.
            3.确保进程的操作是合法的.
            防止越界,防止越权
        请求调页/预先调页

页表项设计:
    页表由页表项组成.
    页框号(内存块号/物理页面号/页帧号)
    有效位(驻留位/中断位):表示该页是在内存还是磁盘(1/0表示)
    访问位:引用位(不明白)
    修改位:此页在内存中是否被修改过(应该就是代表是否脏页)
    保护位: 读/可读写
    通常页表项是硬件设计的.
    页表页在内存中若不连续存放,则需要引入页表页的地址索引表->页目录(Page Directory)

    二级页表结构:
        页目录: 每个进程都有一个
        当CPU执行进程时,页目录地址会加载到寄存器(x86架构下是cr3)中
        当进程下CPU时这个页目录地址会保存在进程的PCB中
    |----------------------------------------|
    |页目录偏移   |页表偏移   |页内偏移        |
    |----------------------------------------|    
    32          21          11               0
    I385页目录和页表项:
    页目录项 PDE(page directory entry)
    |------------------------------------------|
    |PFN      |Avail|G|PS|O|A|PCD|PWT|U/S|R/W|P|
    |------------------------------------------|  
    页表项 PTE(page table entry)
    |------------------------------------------|
    |PFN      |Avail|G|O|D|A|PCD|PWT|U/S|R/W|P|
    |------------------------------------------|     
    PFN(page frame number): 页框号
    P(present): 有效位
    A(accessed): 访问位
    R/W(read/write): 只读/可读写
    U/S(user/supervisor): 用户/内核
    PWT(page write through): 缓存写策略
    PCD(page cache disable): 禁止缓存
    PS(page size): 大页4M(1的话)
引入反转(倒排)页表
    地址转换: 从虚拟地址空间出发 虚拟地址->查页表->得到页框号->形成物理地址
        问题: 页表占用大量空间.以及每一个进程需要一张页表
    解决思路:
        从物理地址空间出发,系统建立一张页表(所有进程共享一个页表)
        页表项记录进程i的某虚拟地址(虚页号)与页框号的映射关系
MMU: 将虚拟地址转换为物理地址
    问题:页表两次货两次以上的内存访问;(如多级页表)
    CPU的指令处理速度与内存指令的访问速度差异大,CPU的速度得不到充分利用!

程序访问的局部性->引入快表(TLB/Translation Look-aside Buffers)
时间局部性: 就是说同一个地方可能会在将来多次访问
空间局部性: 大意是访问的位置将来可能会访问这个临近该位置的数据

快表(TLB/Translation Look-aside Buffers):
    在CPU中引入的高速缓存,可以匹配CPU的处理速率和内存的访问速度.
    一种随机存取型存储器,除连线寻址机制外,还有接线逻辑,能按特定的匹配标志在一个存储周期内对所有的字同时进行比较.
    1.相联存储器(associative memory)
        特点: 按内容并行查找
    2.保存正在运行进程的页表的子集(部分页表项)
页错误(Page fault):
    又称页面错误,页故障,页面失效.
    地址转换过程中硬件产生的异常.
    具体原因:
        1.所访问的虚拟页面没有调入物理内存(缺页异常).
        2.页面访问违反权限(读/写,用户/内核).
        3.错误的访问地址.(访问非法地址)
        4. ....
    缺页异常处理:
        1.是一种Page fault
        2.在地址映射过程中,硬件检查页表时发现所要访问的页面不在内存,则产生该异常--缺页异常!
        3.操作系统执行缺页异常处理程序:获得磁盘地址,启动磁盘,将该页调入内存.
驻留集:
    驻留集大小: 给每个进程分配多少页框?
    分配策略:
        1.固定分配策略
          进程创建时指定
          可以根据进程类型(交互/批处理/应用类)或者基于程序员或系统管理员的需要来确定.
        2.可变分配策略
          根据缺页率评估进程局部性表现.
          缺页率高->增加页框数
          缺页率低->减少页框数
          系统开销
    置换问题:
        置换范围:
            计划置换页面的集合是局限在产生缺页中断的进程,还是所有进程的页框?
            1.局部置换策略: 仅在产生本地缺页的进程的驻留集中选择.
            2.全局置换策略: 将内存中所有未锁定的页框都作为置换的候选.
        置换策略:
            在计划置换的页框集合中,选择换出哪一个页框
            决定置换当前内存中的哪一个页框.
            所有策略的目标: 置换最近最不可能访问的页.
            根据局部性原理: 最近的访问历史和最近将要访问的模式间存在相关性.因此,大多数策略都基于过去的行为来预测将来的行为.
            约束: 不能置换被锁定的页框.
    页框锁定:
        1.采用虚拟技术后存在开销->使进程运行时间变得不确定.
        2.给每一页框增加一个锁定位.
        3.通过设置相应的锁定位,不让操作系统将进程使用的页面换出内存,避免陈胜由交换过程带来的不确定的延迟.
          如: 操作系统核心代码,关键数据结构,I/O缓冲区,特别是正在I/O的内存页面
        windows提供锁定页框API(数量有限制): VirtualLock和VirtualUnLock函数
    清除策略:
        1.清除: 从进程的驻留集中收回页框.
        2.虚拟页式系统工作的最佳状态: 发生缺页异常时,系统中有大量的空闲页框.
          结论: 在系统中保存一定数目的空闲页框供给比使用所有内存并在需要时搜索一个页框有更好的性能.
          * 设计一个分页守护进程(paging daemon),多数时间睡眠,可定期唤醒以检查内存的状态.
          * 如果空闲页框过少,分页守护进程通过预定的页面置换算法选择页面换出内存.
          * 如果页面装入内存后被修改过,则将他们写回磁盘,分页守护进程可以保证所有的空闲页框是"干净"的.
        3.当进程需要使用一个已置换出的页框时,如果该页框还没有被新的内容覆盖,则将它从空闲页框集中移出即可恢复该页.
          *页缓存技术:
            1.不丢弃置换出的页,将他们放入两个表之一;如果未被修改,则放到空闲页链表中;如果修改了,则放到修改页链表中.
            2.被修改的页定期写回磁盘(不是一次只写一个,大大减少I/O操作的数量,从而减少了磁盘访问时间)
            3.被置换的页仍然保存在内存中,一旦进程又要访问该页,可以迅速将它加入该进程的驻留集合(代价很小)

    页面置换算法:
        又称页面淘汰(替换)算法.
        1.最佳算法(OPT)
            置换以后不再需要或最远的将来才会用到的页面
            作用: 作为所有衡量置换算法性能的一个标准!
        2.先进先出
            含义: 选择在内存中驻留时间最长的页并置换它
            实现: 页面链表法.
        3.第二次机会(SCR)
            SCR-Second Chance
            按照先进先出算法选择某一页面,检查其访问位R,如果为0,则置换该页;如果为1,则给第二次机会,并将访问位 置0
        4.时钟算法(Clock)
        5.最近未使用(NRU)
            Not Recently Used : 选择在最近一段时间内未使用过的一页并置换.
            实现: 设置页表项的两位
                  访问位(R),修改位(M)
        6.最近最少使用(LRU)
            Least Recently Used: 选择最后一次访问时间距离当前时间最长的一页并置换.即置换未使用时间最长的一页.
            性能接近OPT
            实现: 时间戳或维护一个访问页的战(开销大)
        7.最不经常使用(NFC)
        8.老化算法(AGING)
        9.工作集
            影响缺页次数的因素:
                1.页面置换算法
                2.页面本身的大小
                3.程序的编制方法
                4.分配给进程的页框数量
           颠簸(Thrashing,抖动):
               虚存中,页面在内存与磁盘之间频繁调度,使得调度页面所需的时间比进程实际运行的时间还多,这样导致系统效率急剧下降,
           这种现象称为颠簸或抖动.
        10.工作集(working set)时钟
            基本思想:
                根据程序的局部性原理,一般情况下,进程在一段时间内总是集中访问一些页面,这些页面能成为活跃页面,如果分配给一个
            进程的物理页面数太少了,使该进程所需的活跃页面将不能全部装入内存,则进程在运行过程中将频繁发生中断.
            工作集: 一个进程当前正在使用的页框集合.
            工作集算法:
                基本思路: 找出一个不在工作集中的页面并置换它.
    BELADY现象:
        FIFO页面置换算法会产生异常现象(Belady现象),即: 当分配给进程的物理页面数增加时,缺页次数反而增加.
内存映射文件:
    1.基本思想:
        进程通过一个系统调用(mmap)将一个文件(或部分)映射到其虚拟地址空间的一部分,访问这个文件就像访问内存中的一个大数组,而不
    是对文件进行读写.
    2.在多数实现中,在映射共享的页面时不会实际读入页面的内容,而是在访问页面时,页面才会被每次一页的读入,磁盘文件则被当做后备存储.
    3.当进程修改或显示地解除文件映射是,所有被修改页面会写回文件.
    写时复制技术(COW):fork调用
        两个进程共享三个页,每页都标志成写时复制.
        新复制的页面对执行写操作的进程是私有的,对其他共享写时复制页面的进程是不可见的.
文件系统:
    操作系统中统一管理信息资源的一种软件,管理文件的存储,检索,更新,提供安全可靠的共享和保护手段,并且方便用户使用.
    1.统一管理磁盘空间,实施磁盘空间的分配与回收
    2.实现文件的按名存取, 名字空间 -映射-->磁盘空间
    3.实现文件信息的共享,并提供文件的保护,保密手段
    4.向用户提供一个方便使用,易于维护的接口,并向用户提供有关统计信息
    5.提高文件系统的性能
    6.提供与I/O系统的统一接口

    文件的分类:
        普通文件(regular): 包含了用户的信息,一般为ASCII或者二进制文件
        目录文件(directory): 管理文件系统的系统文件
        特殊文件(special file):
            字符串设备文件: 和输入输出有关,用于模仿串行I/O设备,例如终端,打印机,网卡等.
            块设备文件: 磁盘
    文件存取:
        1.顺序存取(访问)
        2.随机存取(访问)
            提供读写位置(当前位置),例如UNIX的seek操作
    典型的磁盘结构:
        任何时刻只有一个磁头处于活动状态: 输入输出数据流以位串行式出现
        物理地址形式: 磁头号(盘面号),磁道号(柱面号),扇区号
        扇区: 标题(10字节),数据(512字节),ECC纠错信息(12-16字节)
    磁盘访问:
        一次访盘请求: 读/写,,磁盘地址(设备号,柱面号,磁头号,扇区号),内存地址(源/目)
        完成过程由三个动作组成:
            1.寻道(时间): 磁头移动定位到指定磁道
            2.旋转延迟(时间): 等待指定扇区从磁头下旋转经过
            3.数据传输(时间): 数据在磁盘与内存之间的数据传输.
    文件属性:
        1.文件控制块(File Control Block)
            为管理文件而设置的数据结构,保存管理文件所需的所有有关信息.(文件属性或元数据)
        2.常用属性
            文件名,文件号,文件大小,文件地址,创建时间,最后修改时间,最后访问时间,保护,口令,创建者,当前拥有者,文件类型,共享技术,
         各种标志(只读/隐藏/系统/归档/ASCII/二进制,顺序/随机访问,临时文件,锁)
    文件操作的实现:
        创建文件:
            建立系统与文件的联系,实质是建立文件的FCB(unix还有inode).
            在目录中为新文件创建一个目录项,根据提供的参数及需要的填写相关内容.
            分配必要的存储空间.
        打开文件:
            根据文件名在文件目录中检索,并将该文件的目录项读入内存,建立相关的数据结构,为后续的文件操作做好准备;
            文件描述符/文件句柄
IO:
    设备的分类--按数据组织分
        1.块设备
            以数据为单位存储,传输信息
            传输速率较高,可寻址(随机读写)
        2.字符串设备
            以字符为单位存储,传输信息
            传输速率低,不可寻址
    设备的分类--从资源分配角度
        1.独占设备
            在一段时间内只有能一个进程使用的设备,一般为低俗I/0(如打印机/磁带等)
        2.共享设备
            在一段时间内可能有多个进程共同使用的设备,多个进程以交叉的方式来使用设备,其资源利用率高(如硬盘)
        3.虚设备
            在一类设备上模拟另一设备,常用共享设备模拟独占设备,用告诉设备模拟低俗设备,被模拟的设备成为虚设备.
            目的: 将慢速的独占设备改造成多个用户可共享的设备,提高设备的利用率.
            案例: spooling技术
    IO管理的目标和任务:
        (1) 按照用户的请求,控制设备的各种操作,完成IO设备与内存之间的数据交换,最终完成用户的IO请求.
            1.1 设备分配与回收
                记录设备的状态
                根据用户的请求和设备的类型,采用一定的分配算法,选择一条数据通路
            1.2执行设备驱动程序,实现真正的IO操作
            1.3设备中断处理: 处理外部设备的中断
            1.4缓冲区管理: 管理IO缓冲区
         (2) 建立方便,统一的独立于设备的接口(封装,屏蔽硬件底层细节)
            2.1 方便性: 向用户提供使用外部设备的方便接口,使用户编程时不考虑设备的复杂物理特性.
            2.2 统一性: 对不同的设备采取统一的操作方式,即在用户程序中使用的是逻辑设备.
                逻辑设备与物理设备
                屏蔽硬件细节(设备的物理特性,错误处理,不同IO过程的差异性)
         (3) 充分利用各种技术(管道,中断,缓冲,异步IO等)提高COU与设备,设备与设备之间的并行工作能力,充分利用资源,提高资源利用率.
             并行
             均衡性(使设备充分忙碌)
    IO设备组成:
        1.IO设备一般由机械和电子两部分组成
           (1) 机械部分是设备本身(物理装置)
           (2) 电子部分又称设备控制器(或适配器)
                -(端口) 地址译码
                - 按照主机与设备之间约定的格式和过程接受计算机发来的数据和控制信号 或向主机发送数据和状态信号.
                - 将计算机的数字信号转换成机械部分能识别的模拟信号.或反之.
                - 实现设备内部硬件缓冲,数据加工等提高性能或增强功能
        设备接口--控制器作用
            1.操作系统将命令写入控制器的接口寄存器(或接口缓冲区)中,以实现输入/输出,并从接口寄存器读取状态信息或结果信息.
            2.当控制器接受一条命令后,可独立于CPU完成指定操作,CPU可以另外执行其他计算;命令完成时,控制器产生一个中断,CPU响应中断,
        中断转给操作系统;通过读控制寄存器中的信息,获得操作结果和设备状态;
            3.控制器与设备之间的接口常常是一个低级接口
            4.控制器的任务: 把串行的位流转换为字节块,并进行必要的错误修正;首先,控制器按位进行组装,然后存入控制器内部的缓冲区中
        形成以字节为单位的块;在对块验证检查合并证明无错误时,再将它复制到内存中.
    I/O端口地址
        1.I/O端口地址: 接口电路中每个寄存器具有的,唯一的地址,是个整数.
        2.所有I/O端口地址形成I/O端口空间(受到保护)
        I/O指令形式与I/O地址是互相关联的,主要有两种形式:
            (1)I/O独立编址(I/O专用指令)
                1.1分配给系统中所有端口的地址空间完全独立,与内存地址空间无关
                1.2使用专门的I/O指令对端口进行操作
                1.3优点:
                    外设不占用内存的地址空间
                    编程时,易于区分是对内存操作还是对I/O操作
                1.4缺点:
                    I/O端口操作指令类型少
                    操作不灵活
                1.5例子:
                    8086/8088,分配给I/O端口的地址空间64K,0000H~0FFFFH,只能用in和out指令进行读写操作
            (2)内存映像编址(内存映像I/O模式)
                1.分配给系统中所有端口的地址空间与内存的地址空间统一编址.
                2.把I/O端口看做一个存储单元,对I/O的读写操作等同于对内存的操作
                3.优点:
                    凡是可对内存操作的指令都可以对I/O端口操作.
                    不需要专门的I/O指令.
                    I/O端口可占有较大的地址空间.
                4.缺点:
                    占用内存空间.
        内存映射I/O的优点:
            1.不需要特殊的保护机制来阻止用户进程执行I/O操作.
                操作系统必须要做的事情: 避免把包含控制寄存器的那部分地址空间放入任何用户的虚拟地址空间之中.
            2.可以引用内存的每一条指令也可以引用控制寄存器
                例如:如果指令TEST可以测试一个内存字是否为0,那么也可以用来测试一个控制寄存器是否为0;
        内存映射I/O的缺点:
            不能对一个设备寄存器进行高速缓存.
    I/O控制方式:
        1.可编程I/O(轮训/查询)
            由CPU代表进程I/O模块发I/O命令,进程进入忙等待,直到操作完成才继续执行.
        2.中断驱动I/O
            为了减少设备驱动程序不断地询问控制器状态寄存器的开销.
            I/O操作结束后,由设备控制器诸佛那个通知设备驱动程序
        3.DMA
    I/O部件的演化:
        1.CPU直接控制外围设备
        2.增加了控制器或I/O部件，CPU使用非中断的可编程l/O
          CPU开始从外部设备接口的具体细节中分离出来.
        3.与2相同，但采用了中断方式
          CPU无需花费等待执行一次I/0操作所需的时间，效率提高
        4.I/0部件通过DMA直接控制存储器
          可以在没有CPU参与的情况下，从内存中移出或者往内存中,移入一块数据，仅仅在传送开始和结束时需要CPU干预.
        5.I/0 部件增强为一个单独的处理器，有专门为/0设计的指令集; CPU指导I/O处理器在执行内存中的一一个I/0程序。I/0处理器在
        没有CPU干涉的情况下取指令并执行这些指令.
        6. I/0部件有自己的局部存储器(其本身就是一台计算机)
            使用这种体系结构可以控制许多I/0设备，并且使需要CPU参与程度降到最小(通常用于控制与交互终端的通信，I/0处理器
        负责大多数控制终端的任务)









