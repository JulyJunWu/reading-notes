信号量: mutex,初始值为1
在临界区之前实施P(mutex) 减一
在临界区之后实施V(mutex) 加一

管程Monitor: 一种同步机制
    进程只能通过调用管程中的过程来间接地访问管程中的数据结构!
    不适用于多处理器情况
    互斥:
        管程是互斥进入的!
        管程的互斥性是由编译机负责保证的!
    同步:
        管程中设置条件变量以及等待/唤醒操作以解决同步问题!
        可以让一个进程或线程在条件变量上等待,也可以通过发送信号将等待在条件变量上的进程或线程唤醒!
    wait/signal 进程之间的通讯
    wait(c):
        如果紧急等待队列非空,则唤醒第一个等待者;否则释放管程的互斥权,执行此操作的进程进入c链末尾!
    使用notify注意问题:
        notify结果: 位于条件队列头的进程在将来合适的时候且当处理器可用时恢复执行.
        由于不能保证在它之前  没有其他进程进入管程,因而这个进程必须重新检查条件.
    broadcast: 使所有在该条件上等待的进程都被释放并进入就绪队列.
Pthread:
    Pthread_mutex_init
    Pthread_mutex_destory
    Pthread_mutex_lock
    Pthread_mutex_trylock
    Pthread_mutex_unlock
    Pthread_cond_init
    Pthread_cond_destory
    Pthread_cond_wait
    Pthread_cond_signal
    Pthread_cond_broadcast

进程之间通信:
    共享内存
    PIPE
Linux:
    管道,消息队列,共享内存,信号量,信号,套接字
    内核同步机制: 原子操作,自旋锁,读写锁,信号量,屏障...

内核地址空间
用户地址空间
    两者都包含: 代码段,数据段,堆,栈
地址重定位:
    逻辑地址: 相对地址,虚拟地址
        用户程序经过编译,汇编后形成目标代码,目标代码通常采用相对地址的形式,其首地址为0,其余地址都相对于首地址而编址.
        不能用逻辑地址在内存中读取信息.
    物理地址: 绝对地址,实地址
        内存中存储单元的地址,可直接寻址!
    为了保证CPU执行指令时可正确访问内存单元,需要将用户程序中的逻辑地址转换为运行时可由机器直接寻址的物理地址,
    这一过程称为地址重定向.
静态重定位:
    当用户程序加载到内存时,一次性实现逻辑地址到物理地址的转换!
    优点: 程序可直接执行!
    缺点: 不能随意改变逻辑地址,否则需要重新转换!
    一般可以由软件完成.
动态重定位:
    在进程执行过程中进行地址转换,即逐条指令执行时完成地址转换!
    需要硬件部件支持.
重定位寄存器: 可能是用来保存该进程在物理内存中的基址地址(起始地址)
内存管理单元(MMU): memory management unit,用来将逻辑地址转换为物理地址

空闲内存管理:
    等长划分/不等长划分
    数据结构:
        位图: 每个分配单元对应于位图中的一位,比如0代表空闲,1表示占用
        空闲区表,已分配区表            
        空闲块链表
内存分配算法:
    1.首次适配 first fit
        在空闲区表中找到第一个满足进程要求的空闲区
    2.下次适配 next fit
        从上次找到的空闲区处接着查找
    3.最佳适配 best fit
        查找整个空闲区表,找到能够满足进程要求的最小空闲区
    4.最差适配worst fit
        总是分配满足进程要求的最大空闲区.
        将该空闲区分为2部分,一部分为进程使用,另一部分形成一个新的空闲区
伙伴系统:
    一种经典的内存分配方案. linux底层内存管理采用,一种特殊的分离适配算法.
    主要思想:
        将内存按2的幂进行划分,组成若干空闲块链表.查找该链表总能找到满足进程需要的最佳匹配快.
    算法:(可用认为是二分法)
        1.首先将整个可用空间看作一块: 2^U(2的U幂次方)
        2.假设进程申请的空间大小为s,如果满足2^(U-1) < s <= 2^U,则分配整个块;
          否则,将块划分为两个大小相等的伙伴,大小为2^(U-1)
        3.一直划分下去直到产生大于或等于s的最小快.
基本内存管理方案:
    整个进程进入内存中一片连续区域. 这是1,2,3的特性
    1.单一连续区
        一段时间内只有一个进程在内存,简单,内存利用率低.

    2.固定分区
        2.1 把内存空间分割成若干区域,称为分区
        2.2 每个分区的大小可以相同也可以不同
        2.3 分区大小固定不变
        2.4 每个分区装一个且只能装一个进程
    3.可变分区
        3.1 根据进程的需要,把内存空闲空间分割出一个分区,分配给该进程
        3.2 剩余的部分称为新的空闲区
        问题: 外碎片,导致内存利用率下降
        紧缩技术/压缩技术: 移动程序,将所有小的空闲区合并为较大的空闲区,出现新的问题:开销,移动时机
    一个进程进入内存中若干个不连续区域. 这是4,5,6的特性
    4.页式
        设计思想:
            1.用户进程地址空间(虚拟地址)被划分为大小相等的部分,称为页(page)或页面,从0开始编号.
            2.内存空间(物理地址)按照同样大小划分为大小相等的区域,称为页框(page frame)/物理页面/页帧/内存块,从0开始编号;
        内存分配:
            以页为单位进行分配,并按进程需要的页数来分配;逻辑上相邻的页,物理上不一定相邻.
        典型页面尺寸: 4K或者4M,一般为2的幂次方.
        逻辑地址: 页号 + 页内地址(偏移地址)
                    -----------------------
                    |   页号  |  页内地址  |
                    |---------------------|  
        页表:
            虚拟地址和物理地址是通过页表来进行关联映射的,页表中的一项称为页表项;
            页表项: 记录了逻辑页号与页框号的对应关系;
            每个进程有一个页表,存放在内存;
            页表的首个地址存放在页表基址寄存器中(page table base register)
        地址转换(硬件支持)
            CPU取到逻辑地址,自动划分为页号和页内地址,用户页号查询页表的到页框号,再与页内偏移拼接成为物理地址.
        问题:内部碎片
    5.段式
        设计思想:
            1.用户进程地址空间: 按程序自身的逻辑关系划分为若干个程序段,每个程序段都有一个段名.
            2.内存空间被动态划分为若干个长度不相同的区域,成为物理段,每个物理段由起始地址和长度确定.
            内存分配(规则): 以段位单位进行分配,每段在内存中占据连续空间,但各段之间可以不相邻.
        逻辑地址: 段号 + 段内地址 (不是自动划分,必须显示给出)
            -----------------------
            |   段号  |  段内地址  |
            |---------------------|
        段表: 记录逻辑段号与物理内存的映射关系
            1.每项记录了段号,段首地址和段长度之间的关系;
            2.每个进程一个段表,存在在内存
            3.段表其实地址保存在段表基础寄存器
        地址转换(硬件)
            CPU取到逻辑地址,用段号查段表,得到该段在内存的起始地址,与段内地址计算得出物理地址!
    6.段页式
        产生背景:
            综合页式,段式的优点,克服两者的缺点.
        设计思想:
            用户进程划分,先按段划分,每一段再按页面划分
        逻辑地址:
            ------------------------------------
            |     段      |________段内地址______|
            |     号      |   页号   | 业内地址  |
            -------------------------------------
         内存划分: 以页式存储管理方案
         内存分配: 以页为单位进行分配
            









