信号量: mutex,初始值为1
在临界区之前实施P(mutex) 减一
在临界区之后实施V(mutex) 加一

管程Monitor: 一种同步机制
    进程只能通过调用管程中的过程来间接地访问管程中的数据结构!
    不适用于多处理器情况
    互斥:
        管程是互斥进入的!
        管程的互斥性是由编译机负责保证的!
    同步:
        管程中设置条件变量以及等待/唤醒操作以解决同步问题!
        可以让一个进程或线程在条件变量上等待,也可以通过发送信号将等待在条件变量上的进程或线程唤醒!
    wait/signal 进程之间的通讯
    wait(c):
        如果紧急等待队列非空,则唤醒第一个等待者;否则释放管程的互斥权,执行此操作的进程进入c链末尾!
    使用notify注意问题:
        notify结果: 位于条件队列头的进程在将来合适的时候且当处理器可用时恢复执行.
        由于不能保证在它之前  没有其他进程进入管程,因而这个进程必须重新检查条件.
    broadcast: 使所有在该条件上等待的进程都被释放并进入就绪队列.
Pthread:
    Pthread_mutex_init
    Pthread_mutex_destory
    Pthread_mutex_lock
    Pthread_mutex_trylock
    Pthread_mutex_unlock
    Pthread_cond_init
    Pthread_cond_destory
    Pthread_cond_wait
    Pthread_cond_signal
    Pthread_cond_broadcast

进程之间通信:
    共享内存
    PIPE
Linux:
    管道,消息队列,共享内存,信号量,信号,套接字
    内核同步机制: 原子操作,自旋锁,读写锁,信号量,屏障...

内核地址空间
用户地址空间
    两者都包含: 代码段,数据段,堆,栈
地址重定位:
    逻辑地址: 相对地址,虚拟地址
        用户程序经过编译,汇编后形成目标代码,目标代码通常采用相对地址的形式,其首地址为0,其余地址都相对于首地址而编址.
        不能用逻辑地址在内存中读取信息.
    物理地址: 绝对地址,实地址
        内存中存储单元的地址,可直接寻址!
    为了保证CPU执行指令时可正确访问内存单元,需要将用户程序中的逻辑地址转换为运行时可由机器直接寻址的物理地址,
    这一过程称为地址重定向.
静态重定位:
    当用户程序加载到内存时,一次性实现逻辑地址到物理地址的转换!
    优点: 程序可直接执行!
    缺点: 不能随意改变逻辑地址,否则需要重新转换!
    一般可以由软件完成.
动态重定位:
    在进程执行过程中进行地址转换,即逐条指令执行时完成地址转换!
    需要硬件部件支持.
重定位寄存器: 可能是用来保存该进程在物理内存中的基址地址(起始地址)
内存管理单元(MMU): memory management unit,用来将逻辑地址转换为物理地址

空闲内存管理:
    等长划分/不等长划分
    数据结构:
        位图: 每个分配单元对应于位图中的一位,比如0代表空闲,1表示占用
        空闲区表,已分配区表            
        空闲块链表
内存分配算法:
    1.首次适配 first fit
        在空闲区表中找到第一个满足进程要求的空闲区
    2.下次适配 next fit
        从上次找到的空闲区处接着查找
    3.最佳适配 best fit
        查找整个空闲区表,找到能够满足进程要求的最小空闲区
    4.最差适配worst fit
        总是分配满足进程要求的最大空闲区.
        将该空闲区分为2部分,一部分为进程使用,另一部分形成一个新的空闲区
伙伴系统:
    一种经典的内存分配方案. linux底层内存管理采用,一种特殊的分离适配算法.
    主要思想:
        将内存按2的幂进行划分,组成若干空闲块链表.查找该链表总能找到满足进程需要的最佳匹配快.
    算法:(可用认为是二分法)
        1.首先将整个可用空间看作一块: 2^U(2的U幂次方)
        2.假设进程申请的空间大小为s,如果满足2^(U-1) < s <= 2^U,则分配整个块;
          否则,将块划分为两个大小相等的伙伴,大小为2^(U-1)
        3.一直划分下去直到产生大于或等于s的最小快.
基本内存管理方案:
    整个进程进入内存中一片连续区域. 这是1,2,3的特性
    1.单一连续区
        一段时间内只有一个进程在内存,简单,内存利用率低.

    2.固定分区
        2.1 把内存空间分割成若干区域,称为分区
        2.2 每个分区的大小可以相同也可以不同
        2.3 分区大小固定不变
        2.4 每个分区装一个且只能装一个进程
    3.可变分区
        3.1 根据进程的需要,把内存空闲空间分割出一个分区,分配给该进程
        3.2 剩余的部分称为新的空闲区
        问题: 外碎片,导致内存利用率下降
        紧缩技术/压缩技术: 移动程序,将所有小的空闲区合并为较大的空闲区,出现新的问题:开销,移动时机
    一个进程进入内存中若干个不连续区域. 这是4,5,6的特性
    4.页式
        设计思想:
            1.用户进程地址空间(虚拟地址)被划分为大小相等的部分,称为页(page)或页面,从0开始编号.
            2.内存空间(物理地址)按照同样大小划分为大小相等的区域,称为页框(page frame)/物理页面/页帧/内存块,从0开始编号;
        内存分配:
            以页为单位进行分配,并按进程需要的页数来分配;逻辑上相邻的页,物理上不一定相邻.
        典型页面尺寸: 4K或者4M,一般为2的幂次方.
        逻辑地址: 页号 + 页内地址(偏移地址)
                    -----------------------
                    |   页号  |  页内地址  |
                    |---------------------|  
        页表:
            虚拟地址和物理地址是通过页表来进行关联映射的,页表中的一项称为页表项;
            页表项: 记录了逻辑页号与页框号的对应关系;
            每个进程有一个页表,存放在内存;
            页表的首个地址存放在页表基址寄存器中(page table base register)
        地址转换(硬件支持)
            CPU取到逻辑地址,自动划分为页号和页内地址,用户页号查询页表的到页框号,再与页内偏移拼接成为物理地址.
        问题:内部碎片
    5.段式
        设计思想:
            1.用户进程地址空间: 按程序自身的逻辑关系划分为若干个程序段,每个程序段都有一个段名.
            2.内存空间被动态划分为若干个长度不相同的区域,成为物理段,每个物理段由起始地址和长度确定.
            内存分配(规则): 以段位单位进行分配,每段在内存中占据连续空间,但各段之间可以不相邻.
        逻辑地址: 段号 + 段内地址 (不是自动划分,必须显示给出)
            -----------------------
            |   段号  |  段内地址  |
            |---------------------|
        段表: 记录逻辑段号与物理内存的映射关系
            1.每项记录了段号,段首地址和段长度之间的关系;
            2.每个进程一个段表,存在在内存
            3.段表其实地址保存在段表基础寄存器
        地址转换(硬件)
            CPU取到逻辑地址,用段号查段表,得到该段在内存的起始地址,与段内地址计算得出物理地址!
    6.段页式
        产生背景:
            综合页式,段式的优点,克服两者的缺点.
        设计思想:
            用户进程划分,先按段划分,每一段再按页面划分
        逻辑地址:
            ------------------------------------
            |     段      |________段内地址______|
            |     号      |   页号   | 页内地址  |
            -------------------------------------
        内存划分: 以页式存储管理方案
        内存分配: 以页为单位进行分配
        数据结构及有关操作:
            段表: 记录了每一段的页表起址和页表长度
            页表: 记录了逻辑页号与页框号的对应关系
            每一段有一张页表,一个进程有多少页表
        空闲区管理: 同页式管理
        内存分配/回收: 同页式管理
内存"扩充"技术:
    1.内存紧缩技术(如可变分区)
    2.覆盖技术 overlaying
        解决问题: 程序大小超过物理内存总和
        按照自身的逻辑结构,将那些不会同事执行的程序段共享同一块内存区域.
        程序员声明覆盖结构,操作系统完成自动覆盖.
        已过时!
    3.交换技术 swapping(重点)
        设计思想: 内存空间紧张时,系统将内存中某些进程暂时移到外存,把外存中某些进程换进内存,占据前者所占用的区域.
                  进程在内存与磁盘之间的动态调度.
        交换的对象: 运行时创建或修改的内容,栈和堆
        交换区: 一般系统会指定一块特殊的磁盘区域作为交换空间(swap space),包含连续的磁道,操作系统可以使用底层
            的磁盘读写操作对其高效的访问.
        栈和队堆: 相对增长 堆数据->空闲区域<-栈数据
    4.虚拟存储技术 virtual memory
        所谓虚拟存储技术是指: 当进程运行时,先将其一部分装入内存,另一部分暂留在磁盘,当要执行的指令或访问的数据不在
    内存时,由操作系统自动完成将他们从磁盘调入内存的工作.
        虚拟地址空间: 即为分配给进程的虚拟内存
        虚拟地址: 在虚拟内存中指令或数据的位置,该位置可以被访问,仿佛它是内存的一部分.
        存储器的层次结构:
                    -寄存器-
              --高速缓存(cache L1)--
             ---高速缓存(cache L2)---
            ----高速缓存(cache L3)----
           ------------内存------------
          -------------磁盘--------------
            特点: 自下而上速度越来越快,自上而下空间越来越大
        地址保护:
            1.确保每个进程有独立的地址空间.
            2.确保进程访问合法的地址范围.
            3.确保进程的操作是合法的.
            防止越界,防止越权
        请求调页/预先调页

页表项设计:
    页表由页表项组成.
    页框号(内存块号/物理页面号/页帧号)
    有效位(驻留位/中断位):表示该页是在内存还是磁盘(1/0表示)
    访问位:引用位(不明白)
    修改位:此页在内存中是否被修改过(应该就是代表是否脏页)
    保护位: 读/可读写
    通常页表项是硬件设计的.
    页表页在内存中若不连续存放,则需要引入页表页的地址索引表->页目录(Page Directory)

    二级页表结构:
        页目录: 每个进程都有一个
        当CPU执行进程时,页目录地址会加载到寄存器(x86架构下是cr3)中
        当进程下CPU时这个页目录地址会保存在进程的PCB中
    |----------------------------------------|
    |页目录偏移   |页表偏移   |页内偏移        |
    |----------------------------------------|    
    32          21          11               0
    I385页目录和页表项:
    页目录项 PDE(page directory entry)
    |------------------------------------------|
    |PFN      |Avail|G|PS|O|A|PCD|PWT|U/S|R/W|P|
    |------------------------------------------|  
    页表项 PTE(page table entry)
    |------------------------------------------|
    |PFN      |Avail|G|O|D|A|PCD|PWT|U/S|R/W|P|
    |------------------------------------------|     
    PFN(page frame number): 页框号
    P(present): 有效位
    A(accessed): 访问位
    R/W(read/write): 只读/可读写
    U/S(user/supervisor): 用户/内核
    PWT(page write through): 缓存写策略
    PCD(page cache disable): 禁止缓存
    PS(page size): 大页4M(1的话)
引入反转(倒排)页表
    地址转换: 从虚拟地址空间出发 虚拟地址->查页表->得到页框号->形成物理地址
        问题: 页表占用大量空间.以及每一个进程需要一张页表
    解决思路:
        从物理地址空间出发,系统建立一张页表(所有进程共享一个页表)
        页表项记录进程i的某虚拟地址(虚页号)与页框号的映射关系
MMU: 将虚拟地址转换为物理地址
    问题:页表两次货两次以上的内存访问;(如多级页表)
    CPU的指令处理速度与内存指令的访问速度差异大,CPU的速度得不到充分利用!

程序访问的局部性->引入快表(TLB/Translation Look-aside Buffers)
时间局部性: 就是说同一个地方可能会在将来多次访问
空间局部性: 大意是访问的位置将来可能会访问这个临近该位置的数据

快表(TLB/Translation Look-aside Buffers):
    在CPU中引入的高速缓存,可以匹配CPU的处理速率和内存的访问速度.
    一种随机存取型存储器,除连线寻址机制外,还有接线逻辑,能按特定的匹配标志在一个存储周期内对所有的字同时进行比较.
    1.相联存储器(associative memory)
        特点: 按内容并行查找
    2.保存正在运行进程的页表的子集(部分页表项)
页错误(Page fault):
    又称页面错误,页故障,页面失效.
    地址转换过程中硬件产生的异常.
    具体原因:
        1.所访问的虚拟页面没有调入物理内存(缺页异常).
        2.页面访问违反权限(读/写,用户/内核).
        3.错误的访问地址.(访问非法地址)
        4. ....
    缺页异常处理:
        1.是一种Page fault
        2.在地址映射过程中,硬件检查页表时发现所要访问的页面不在内存,则产生该异常--缺页异常!
        3.操作系统执行缺页异常处理程序:获得磁盘地址,启动磁盘,将该页调入内存.
驻留集:
    驻留集大小: 给每个进程分配多少页框?
    分配策略:
        1.固定分配策略
          进程创建时指定
          可以根据进程类型(交互/批处理/应用类)或者基于程序员或系统管理员的需要来确定.
        2.可变分配策略
          根据缺页率评估进程局部性表现.
          缺页率高->增加页框数
          缺页率低->减少页框数
          系统开销
    置换问题:
        置换范围:
            计划置换页面的集合是局限在产生缺页中断的进程,还是所有进程的页框?
            1.局部置换策略: 仅在产生本地缺页的进程的驻留集中选择.
            2.全局置换策略: 将内存中所有未锁定的页框都作为置换的候选.
        置换策略:
            在计划置换的页框集合中,选择换出哪一个页框
            决定置换当前内存中的哪一个页框.
            所有策略的目标: 置换最近最不可能访问的页.
            根据局部性原理: 最近的访问历史和最近将要访问的模式间存在相关性.因此,大多数策略都基于过去的行为来预测将来的行为.
            约束: 不能置换被锁定的页框.
    页框锁定:
        1.采用虚拟技术后存在开销->使进程运行时间变得不确定.
        2.给每一页框增加一个锁定位.
        3.通过设置相应的锁定位,不让操作系统将进程使用的页面换出内存,避免陈胜由交换过程带来的不确定的延迟.
          如: 操作系统核心代码,关键数据结构,I/O缓冲区,特别是正在I/O的内存页面
        windows提供锁定页框API(数量有限制): VirtualLock和VirtualUnLock函数
    清除策略:
        1.清除: 从进程的驻留集中收回页框.
        2.虚拟页式系统工作的最佳状态: 发生缺页异常时,系统中有大量的空闲页框.
          结论: 在系统中保存一定数目的空闲页框供给比使用所有内存并在需要时搜索一个页框有更好的性能.
          * 设计一个分页守护进程(paging daemon),多数时间睡眠,可定期唤醒以检查内存的状态.
          * 如果空闲页框过少,分页守护进程通过预定的页面置换算法选择页面换出内存.
          * 如果页面装入内存后被修改过,则将他们写回磁盘,分页守护进程可以保证所有的空闲页框是"干净"的.
        3.当进程需要使用一个已置换出的页框时,如果该页框还没有被新的内容覆盖,则将它从空闲页框集中移出即可恢复该页.
          *页缓存技术:
            1.不丢弃置换出的页,将他们放入两个表之一;如果未被修改,则放到空闲页链表中;如果修改了,则放到修改页链表中.
            2.被修改的页定期写回磁盘(不是一次只写一个,大大减少I/O操作的数量,从而减少了磁盘访问时间)
            3.被置换的页仍然保存在内存中,一旦进程又要访问该页,可以迅速将它加入该进程的驻留集合(代价很小)

    页面置换算法:
        又称页面淘汰(替换)算法.
        1.最佳算法(OPT)
            置换以后不再需要或最远的将来才会用到的页面
            作用: 作为所有衡量置换算法性能的一个标准!
        2.先进先出
            含义: 选择在内存中驻留时间最长的页并置换它
            实现: 页面链表法.
        3.第二次机会(SCR)
            SCR-Second Chance
            按照先进先出算法选择某一页面,检查其访问位R,如果为0,则置换该页;如果为1,则给第二次机会,并将访问位 置0
        4.时钟算法(Clock)
        5.最近未使用(NRU)
            Not Recently Used : 选择在最近一段时间内未使用过的一页并置换.
            实现: 设置页表项的两位
                  访问位(R),修改位(M)
        6.最近最少使用(LRU)
            Least Recently Used: 选择最后一次访问时间距离当前时间最长的一页并置换.即置换未使用时间最长的一页.
            性能接近OPT
            实现: 时间戳或维护一个访问页的战(开销大)
        7.最不经常使用(NFC)
        8.老化算法(AGING)
        9.工作集
            影响缺页次数的因素:
                1.页面置换算法
                2.页面本身的大小
                3.程序的编制方法
                4.分配给进程的页框数量
           颠簸(Thrashing,抖动):
               虚存中,页面在内存与磁盘之间频繁调度,使得调度页面所需的时间比进程实际运行的时间还多,这样导致系统效率急剧下降,
           这种现象称为颠簸或抖动.
        10.工作集(working set)时钟
            基本思想:
                根据程序的局部性原理,一般情况下,进程在一段时间内总是集中访问一些页面,这些页面能成为活跃页面,如果分配给一个
            进程的物理页面数太少了,使该进程所需的活跃页面将不能全部装入内存,则进程在运行过程中将频繁发生中断.
            工作集: 一个进程当前正在使用的页框集合.
            工作集算法:
                基本思路: 找出一个不在工作集中的页面并置换它.
    BELADY现象:
        FIFO页面置换算法会产生异常现象(Belady现象),即: 当分配给进程的物理页面数增加时,缺页次数反而增加.
内存映射文件:
    1.基本思想:
        进程通过一个系统调用(mmap)将一个文件(或部分)映射到其虚拟地址空间的一部分,访问这个文件就像访问内存中的一个大数组,而不
    是对文件进行读写.
    2.在多数实现中,在映射共享的页面时不会实际读入页面的内容,而是在访问页面时,页面才会被每次一页的读入,磁盘文件则被当做后备存储.
    3.当进程修改或显示地解除文件映射是,所有被修改页面会写回文件.
    写时复制技术(COW):fork调用
        两个进程共享三个页,每页都标志成写时复制.
        新复制的页面对执行写操作的进程是私有的,对其他共享写时复制页面的进程是不可见的.
文件系统:
    操作系统中统一管理信息资源的一种软件,管理文件的存储,检索,更新,提供安全可靠的共享和保护手段,并且方便用户使用.
    1.统一管理磁盘空间,实施磁盘空间的分配与回收
    2.实现文件的按名存取, 名字空间 -映射-->磁盘空间
    3.实现文件信息的共享,并提供文件的保护,保密手段
    4.向用户提供一个方便使用,易于维护的接口,并向用户提供有关统计信息
    5.提高文件系统的性能
    6.提供与I/O系统的统一接口

    文件的分类:
