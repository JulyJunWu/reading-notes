信号量: mutex,初始值为1
在临界区之前实施P(mutex) 减一
在临界区之后实施V(mutex) 加一

管程Monitor: 一种同步机制
    进程只能通过调用管程中的过程来间接地访问管程中的数据结构!
    不适用于多处理器情况
    互斥:
        管程是互斥进入的!
        管程的互斥性是由编译机负责保证的!
    同步:
        管程中设置条件变量以及等待/唤醒操作以解决同步问题!
        可以让一个进程或线程在条件变量上等待,也可以通过发送信号将等待在条件变量上的进程或线程唤醒!
    wait/signal 进程之间的通讯
    wait(c):
        如果紧急等待队列非空,则唤醒第一个等待者;否则释放管程的互斥权,执行此操作的进程进入c链末尾!
    使用notify注意问题:
        notify结果: 位于条件队列头的进程在将来合适的时候且当处理器可用时恢复执行.
        由于不能保证在它之前  没有其他进程进入管程,因而这个进程必须重新检查条件.
    broadcast: 使所有在该条件上等待的进程都被释放并进入就绪队列.
Pthread:
    Pthread_mutex_init
    Pthread_mutex_destory
    Pthread_mutex_lock
    Pthread_mutex_trylock
    Pthread_mutex_unlock
    Pthread_cond_init
    Pthread_cond_destory
    Pthread_cond_wait
    Pthread_cond_signal
    Pthread_cond_broadcast

进程之间通信:
    共享内存
    PIPE
Linux:
    管道,消息队列,共享内存,信号量,信号,套接字
    内核同步机制: 原子操作,自旋锁,读写锁,信号量,屏障...

内核地址空间
用户地址空间
    两者都包含: 代码段,数据段,堆,栈
地址重定位:
    逻辑地址: 相对地址,虚拟地址
        用户程序经过编译,汇编后形成目标代码,目标代码通常采用相对地址的形式,其首地址为0,其余地址都相对于首地址而编址.
        不能用逻辑地址在内存中读取信息.
    物理地址: 绝对地址,实地址
        内存中存储单元的地址,可直接寻址!
    为了保证CPU执行指令时可正确访问内存单元,需要将用户程序中的逻辑地址转换为运行时可由机器直接寻址的物理地址,
    这一过程称为地址重定向.
静态重定位:
    当用户程序加载到内存时,一次性实现逻辑地址到物理地址的转换!
    优点: 程序可直接执行!
    缺点: 不能随意改变逻辑地址,否则需要重新转换!
    一般可以由软件完成.
动态重定位:
    在进程执行过程中进行地址转换,即逐条指令执行时完成地址转换!
    需要硬件部件支持.
重定位寄存器: 可能是用来保存该进程在物理内存中的基址地址(起始地址)
内存管理单元(MMU): memory management unit,用来将逻辑地址转换为物理地址

空闲内存管理:
    等长划分/不等长划分
    数据结构:
        位图: 每个分配单元对应于位图中的一位,比如0代表空闲,1表示占用
        空闲区表,已分配区表            
        空闲块链表
内存分配算法:
    1.首次适配 first fit
        在空闲区表中找到第一个满足进程要求的空闲区
    2.下次适配 next fit
        从上次找到的空闲区处接着查找
    3.最佳适配 best fit
        查找整个空闲区表,找到能够满足进程要求的最小空闲区
    4.最差适配worst fit
        总是分配满足进程要求的最大空闲区.
        将该空闲区分为2部分,一部分为进程使用,另一部分形成一个新的空闲区
伙伴系统:
    一种经典的内存分配方案. linux底层内存管理采用,一种特殊的分离适配算法.
    主要思想:
        将内存按2的幂进行划分,组成若干空闲块链表.查找该链表总能找到满足进程需要的最佳匹配快.
    算法:(可用认为是二分法)
        1.首先将整个可用空间看作一块: 2^U(2的U幂次方)
        2.假设进程申请的空间大小为s,如果满足2^(U-1) < s <= 2^U,则分配整个块;
          否则,将块划分为两个大小相等的伙伴,大小为2^(U-1)
        3.一直划分下去直到产生大于或等于s的最小快.
基本内存管理方案:
    整个进程进入内存中一片连续区域. 这是1,2,3的特性
    1.单一连续区
        一段时间内只有一个进程在内存,简单,内存利用率低.

    2.固定分区
        2.1 把内存空间分割成若干区域,称为分区
        2.2 每个分区的大小可以相同也可以不同
        2.3 分区大小固定不变
        2.4 每个分区装一个且只能装一个进程
    3.可变分区
        3.1 根据进程的需要,把内存空闲空间分割出一个分区,分配给该进程
        3.2 剩余的部分称为新的空闲区
        问题: 外碎片,导致内存利用率下降
        紧缩技术/压缩技术: 移动程序,将所有小的空闲区合并为较大的空闲区,出现新的问题:开销,移动时机
    一个进程进入内存中若干个不连续区域. 这是4,5,6的特性
    4.页式
        设计思想:
            1.用户进程地址空间(虚拟地址)被划分为大小相等的部分,称为页(page)或页面,从0开始编号.
            2.内存空间(物理地址)按照同样大小划分为大小相等的区域,称为页框(page frame)/物理页面/页帧/内存块,从0开始编号;
        内存分配:
            以页为单位进行分配,并按进程需要的页数来分配;逻辑上相邻的页,物理上不一定相邻.
        典型页面尺寸: 4K或者4M,一般为2的幂次方.
        逻辑地址: 页号 + 页内地址(偏移地址)
                    -----------------------
                    |   页号  |  页内地址  |
                    |---------------------|  
        页表:
            虚拟地址和物理地址是通过页表来进行关联映射的,页表中的一项称为页表项;
            页表项: 记录了逻辑页号与页框号的对应关系;
            每个进程有一个页表,存放在内存;
            页表的首个地址存放在页表基址寄存器中(page table base register)
        地址转换(硬件支持)
            CPU取到逻辑地址,自动划分为页号和页内地址,用户页号查询页表的到页框号,再与页内偏移拼接成为物理地址.
        问题:内部碎片
    5.段式
        设计思想:
            1.用户进程地址空间: 按程序自身的逻辑关系划分为若干个程序段,每个程序段都有一个段名.
            2.内存空间被动态划分为若干个长度不相同的区域,成为物理段,每个物理段由起始地址和长度确定.
            内存分配(规则): 以段位单位进行分配,每段在内存中占据连续空间,但各段之间可以不相邻.
        逻辑地址: 段号 + 段内地址 (不是自动划分,必须显示给出)
            -----------------------
            |   段号  |  段内地址  |
            |---------------------|
        段表: 记录逻辑段号与物理内存的映射关系
            1.每项记录了段号,段首地址和段长度之间的关系;
            2.每个进程一个段表,存在在内存
            3.段表其实地址保存在段表基础寄存器
        地址转换(硬件)
            CPU取到逻辑地址,用段号查段表,得到该段在内存的起始地址,与段内地址计算得出物理地址!
    6.段页式
        产生背景:
            综合页式,段式的优点,克服两者的缺点.
        设计思想:
            用户进程划分,先按段划分,每一段再按页面划分
        逻辑地址:
            ------------------------------------
            |     段      |________段内地址______|
            |     号      |   页号   | 页内地址  |
            -------------------------------------
        内存划分: 以页式存储管理方案
        内存分配: 以页为单位进行分配
        数据结构及有关操作:
            段表: 记录了每一段的页表起址和页表长度
            页表: 记录了逻辑页号与页框号的对应关系
            每一段有一张页表,一个进程有多少页表
        空闲区管理: 同页式管理
        内存分配/回收: 同页式管理
内存"扩充"技术:
    1.内存紧缩技术(如可变分区)
    2.覆盖技术 overlaying
        解决问题: 程序大小超过物理内存总和
        按照自身的逻辑结构,将那些不会同事执行的程序段共享同一块内存区域.
        程序员声明覆盖结构,操作系统完成自动覆盖.
        已过时!
    3.交换技术 swapping(重点)
        设计思想: 内存空间紧张时,系统将内存中某些进程暂时移到外存,把外存中某些进程换进内存,占据前者所占用的区域.
                  进程在内存与磁盘之间的动态调度.
        交换的对象: 运行时创建或修改的内容,栈和堆
        交换区: 一般系统会指定一块特殊的磁盘区域作为交换空间(swap space),包含连续的磁道,操作系统可以使用底层
            的磁盘读写操作对其高效的访问.
        栈和队堆: 相对增长 堆数据->空闲区域<-栈数据
    4.虚拟存储技术 virtual memory
        所谓虚拟存储技术是指: 当进程运行时,先将其一部分装入内存,另一部分暂留在磁盘,当要执行的指令或访问的数据不在
    内存时,由操作系统自动完成将他们从磁盘调入内存的工作.
        虚拟地址空间: 即为分配给进程的虚拟内存
        虚拟地址: 在虚拟内存中指令或数据的位置,该位置可以被访问,仿佛它是内存的一部分.
        存储器的层次结构:
                    -寄存器-
              --高速缓存(cache L1)--
             ---高速缓存(cache L2)---
            ----高速缓存(cache L3)----
           ------------内存------------
          -------------磁盘--------------
            特点: 自下而上速度越来越快,自上而下空间越来越大
        地址保护:
            1.确保每个进程有独立的地址空间.
            2.确保进程访问合法的地址范围.
            3.确保进程的操作是合法的.
            防止越界,防止越权
        请求调页/预先调页

页表项设计:
    页表由页表项组成.
    页框号(内存块号/物理页面号/页帧号)
    有效位(驻留位/中断位):表示该页是在内存还是磁盘(1/0表示)
    访问位:引用位(不明白)
    修改位:此页在内存中是否被修改过(应该就是代表是否脏页)
    保护位: 读/可读写
    通常页表项是硬件设计的.
    页表页在内存中若不连续存放,则需要引入页表页的地址索引表->页目录(Page Directory)

    二级页表结构:
        页目录: 每个进程都有一个
        当CPU执行进程时,页目录地址会加载到寄存器(x86架构下是cr3)中
        当进程下CPU时这个页目录地址会保存在进程的PCB中
    |----------------------------------------|
    |页目录偏移   |页表偏移   |页内偏移        |
    |----------------------------------------|    
    32          21          11               0
    I385页目录和页表项:
    页目录项 PDE(page directory entry)
    |------------------------------------------|
    |PFN      |Avail|G|PS|O|A|PCD|PWT|U/S|R/W|P|
    |------------------------------------------|  
    页表项 PTE(page table entry)
    |------------------------------------------|
    |PFN      |Avail|G|O|D|A|PCD|PWT|U/S|R/W|P|
    |------------------------------------------|     
    PFN(page frame number): 页框号
    P(present): 有效位
    A(accessed): 访问位
    R/W(read/write): 只读/可读写
    U/S(user/supervisor): 用户/内核
    PWT(page write through): 缓存写策略
    PCD(page cache disable): 禁止缓存
    PS(page size): 大页4M(1的话)
引入反转(倒排)页表
    地址转换: 从虚拟地址空间出发 虚拟地址->查页表->得到页框号->形成物理地址
        问题: 页表占用大量空间.以及每一个进程需要一张页表
    解决思路:
        从物理地址空间出发,系统建立一张页表(所有进程共享一个页表)
        页表项记录进程i的某虚拟地址(虚页号)与页框号的映射关系
MMU: 将虚拟地址转换为物理地址
    问题:页表两次货两次以上的内存访问;(如多级页表)
    CPU的指令处理速度与内存指令的访问速度差异大,CPU的速度得不到充分利用!

程序访问的局部性->引入快表(TLB/Translation Look-aside Buffers)
时间局部性: 就是说同一个地方可能会在将来多次访问
空间局部性: 大意是访问的位置将来可能会访问这个临近该位置的数据

快表(TLB/Translation Look-aside Buffers):
    在CPU中引入的高速缓存,可以匹配CPU的处理速率和内存的访问速度.
    一种随机存取型存储器,除连线寻址机制外,还有接线逻辑,能按特定的匹配标志在一个存储周期内对所有的字同时进行比较.
    1.相联存储器(associative memory)
        特点: 按内容并行查找
    2.保存正在运行进程的页表的子集(部分页表项)
页错误(Page fault):
    又称页面错误,页故障,页面失效.
    地址转换过程中硬件产生的异常.
    具体原因:
        1.所访问的虚拟页面没有调入物理内存(缺页异常).
        2.页面访问违反权限(读/写,用户/内核).
        3.错误的访问地址.(访问非法地址)
        4. ....
    缺页异常处理:
        1.是一种Page fault
        2.在地址映射过程中,硬件检查页表时发现所要访问的页面不在内存,则产生该异常--缺页异常!
        3.操作系统执行缺页异常处理程序:获得磁盘地址,启动磁盘,将该页调入内存.
驻留集:
    驻留集大小: 给每个进程分配多少页框?
    分配策略:
        1.固定分配策略
          进程创建时指定
          可以根据进程类型(交互/批处理/应用类)或者基于程序员或系统管理员的需要来确定.
        2.可变分配策略
          根据缺页率评估进程局部性表现.
          缺页率高->增加页框数
          缺页率低->减少页框数
          系统开销



