大型分布式网站架构设计与实践(陈康贤)读书笔记(2019-8-10)

知识积累,输入和输出极为重要!

单一应用架构:
	没啥好说的,所有功能都放在同一个进程里;

垂直应用架构 :
	由单一应用架构应变而来,主要是解决了流量的增长,单一机器无法满足性能;
	将原单一的整体进行细度的划分,划分成为各个模块(服务),各模块之间互不干扰;

分布式应用结构:
	由垂直应用架构演变而来,
	业务量的增长,各个服务之间避免不了互相调用,否则不同服务之间存在严重的重叠业务,代码量重复,重复造轮子,
	将业务相同的部分抽取出来独立成为一个服务,以免供彼此之间的互相调用,这样就演变成了分布式应用架构

java中序列化对ObjectOutputStream序列化时,在源代码中需要验证是否序列化如下:
    1.序列化对象是否字符串类型/数组/枚举 -> 如果是走格子的序列化; (底层这些东西都实现了序列化接口)
    2.序列化对象是都实现Serializable接口 ,否则报错 -> NotSerializableException
    3.详情查看ObjectOutputStream 1171行

HTTP : Hypertext Transfer Protocol (超文本传输协议)缩写   
    
网络接口层 -> IP(网络层) -> TCP(传输层) -> HTTP(应用层)

HTTP请求与响应步骤: http://www.google.com:80/index.html
    1.浏览器根据使用的HTTP协议,解析出url对应的域名;
    2.DNS通过域名解析,得到该域名对应的IP地址;
    3.通过url解析出对应端口号(80默认省略)
    4.浏览器发起并建立127.0.0.1:80端口的连接(三次握手);
    5.浏览器向服务器发送GET请求
    6.服务器响应浏览器请求,浏览器读取响应,并渲染网页;
    7.浏览器关闭与服务器的连接;

负载均衡常见算法:
    1.轮询法(牺牲性能)
    2.随机法(若使用轮询法,建议使用随机法替换)
    3.源地址哈希法 通过计算IP的哈希值对服务数量进行取模得到服务地址.使用此算法,在服务不变的情况下,每次的请求都会映射到同一个服务;
        根据此特性,可以在服务消费者和服务提供者之间建立有状态的session会话;
    4.加权轮询法 一般用于服务存在高配和低配配置的情况下
    5.加权随机法
    6.最小连接数法
    
  HTTP未加密的明文
  网关的作用: 接收各种HTTP请求,完成对应的权限与安全校验;
  
  分布式系统基础设施:
    分布式协作及配置管理系统Zookeeper
    分布式缓存系统
       高并发环境下,减轻数据库的压力,提高系统的响应速度和并发吞吐量;
    持久化存储
    分布式消息系统
    搜索引擎
    CDN系统
    负载均衡系统
    日志收集系统
    监控系统
    数据仓库等等
    
  分布式缓存: 
    memcache key-value 时间复杂度O(1)
    基于TCP协议之上的memcache协议通信,协议支持两种数据的传递:
        1.文本行  主要用来承载客户端的的命令以及服务端的响应
        2.非结构化数据 使用字节流的形式在客户端和服务端之间进行传输和存储
    LRU算法 : Least Recently Used : 将最近不常访问的数据剔除 ; mybatis的二级缓存默认也是使用LRU(链表+hash);
  分布式session:
    1.持久化到DB 可以保证宕机是会话不易丢失,然后系统的整体吞吐量影响大
    2.session统一存储在缓存集群 可以保证较高的读,写性能;session的时效性和缓存的失效机制很好利用; 
    
  memcached-session-manager : 
    开源高可用的Tomcat session共享解决方案(其实就是替换tomcat默认的session管理器,tomcat默认的session管理器的实现类是StandardManager);
    替换tomcat session管理器只需要在context.xml中增加一个节点配置;
        <Context>
            <Manager pathname="实现类的全限定类名" />
        </Context>
    两种模式:
        Sticky模式 : 
            每次请求都会被映射到同一台后端web server,直到该服务器宕机,这样就可以将session先存放web server本地,等到请求完成后在同步到memcache服务器;
            当web server宕机时,请求被映射到其他web server,这时候,其他web server可以从memcache server中恢复session;
        Non-Sticky模式 :
            每次请求映射的web server是不确定的,每次请求都从memcache获取session,请求处理完毕时,重新将session放入memcache;
            
  mysql数据库问题: 随着并发量的剧增,单库无法满足,并且随着规模的扩大,数据库的架构会一步一步调整 ,如下,层次逐渐递深
    访问问题: master-slave , 提高读访问响应速度
    master单点故障问题: master-master架构 
    分表:减少单表的记录条数,以便减少数据查询所需时间,提高数据库的吞吐,这就是分表
        分表策略:使用用户ID作为分表字段 , 将用户id对分表的数量进行取模(userId%分表的数量,一般分表的数量为2的次方),得出用户所在数据在哪一张分表中;
        分表解决的痛点:
            解决单个表数据量过大导致查询效率下降的问题;
            却无法解决写入问题,master承载不了写入操作压力时,即使扩展slave也无济于事;所有,新的架构出来了->分库;
    分库:分库采取的策略与分表相似,都是采用一个关键字段进行取模得到数据库的路由;
    分库分表:为了提高数据库访问的压力,又解决海量数据的存储问题
        路由策略:
            1.中间变量=user_id%(库数量*每个库的表数量) ; (此处每个库的表述数量我理解为是同一张表的分表数量)
            2.库=取整(中间变量/每个库的表数量);
            3.表=中间变量%每个库的表数量;
        新的问题:
            分布式事务
            扩容数据迁移问题
         Hbase海量数据的存出,表的分区,并发写入能力
            
  HBase : 高可靠性,高可扩展性,实时读写的**列式存储数据库**   
    HMaster
    HRegionServer
    当表的记录数增加不断变大,将会分裂成一个个region,每个region可以由startKey和endKey表示(管理数据的范围)
    HBase基本命令:
        若命令不会使用直接使用help
        进入shell命令行 : 
            [root@server-1 bin]# ./hbase shell
        查看集群状态 : 
            hbase(main):001:0> status
        创建表:
            创建一个表,并指定表的列族名称 , 格式 create '表明','列族名称1','列族名2','列族名N'
            hbase(main):003:0> create 'user','phone','info'
        列出已存在的表:
            hbase(main):009:0> list
        查看单个表的详细描述:
            hbase(main):010:0> describe 'user'
        新增列族:
            hbase(main):012:0> alter 'user',NAME=>'address' ; NAME大写
        删除列族:
            hbase(main):014:0> alter 'user',NAME=>'address',METHOD=>'delete'
        删除表:
            删除表之前必须将表禁用
            hbase(main):015:0> disable 'user'
            hbase(main):016:0> drop 'user'
        新增表数据:
            格式: put '表名','rowKey','列族:列名','值';
            hbase(main):027:0> put 'user','1','info:name','zws'
        查看数据:
            1.根据rowKey查看 
                get '表名','rowKey';
                hbase(main):028:0> get 'user','1'
            2.根据rowKey查看具体列
                get '表名','rowKey','列族,列名';
                hbase(main):029:0> get 'user','1','info:name'
            3.全表扫描
                hbase(main):031:0> scan 'user'
            4.根据表明和列族名扫描
                hbase(main):033:0> scan 'user',{COLUMNS=>'info'}
            5.查询分页
                hbase(main):036:0> scan 'user',{COLUMNS=>'info',LIMIT=>2}
        查看表记录数:
            hbase(main):030:0> count 'user'
        删除数据:
            1.删除一列数据
                格式: delete '表名','rowKey','列族:需要删除的列名'
                hbase(main):111:0> delete 'user','1','info:name'
            2.删除一行数据 , 将这表rowKey的数据全部删掉
                hbase(main):124:0> deleteall 'user','1'

  Redis:
    高性能key-value数据库 丰富的数据结构(strings,list,set,hash,sorted set等等)
    
  消息队列:
    消息队列可以作为应用通讯的一种方式; 异步 降低系统集成的耦合度,提升了分布式系统协作的效率 , 更快响应用户,提高吞吐量
    当系统处于峰值压力时,消息队列可作为缓冲,缓解集群的压力
    ActiveMQ :
        apache提供的开源消息系统
        完全JAVA实现
        很好支持J2EE的JMS规范(JMS规范相当于java中sql的规范,提供了一系列接口规范,却没有提供实现,实现都是交给各大厂商实现)
         JMS支持两种消息发送和接收模型:
            1.P2P (point-to-point) 点对点 : 基于queue的,消息生产者发送消息到消息队列,消息消费者从队列接收消息(生产者发送一条消息到queue，只有其中一个消费者能收到。)
            2.Pub/Sub (发布/订阅) : 定义如何向一个内容节点发布和订阅消息 , 内容节点成为主题(topic)    
                消息发布者将消息发布在指定的主题,消息订阅者指定订阅某个主题进行消息消费;
                与点对点不同的是,发布/订阅模式支持一对多消费;比如在kafka中多个group.id对主题进行订阅消费.不同的group.id都有自己的偏移量
     linux下安装单机版: 下载 wget http://archive.apache.org/dist/activemq/apache-activemq/5.9.0/apache-activemq-5.9.0-bin.zip           
                 解压即可 : tar -xf apache-activemq-5.9.0-bin.zip 
                 启动: 找到bin目录 , 执行 activemq start | restart | status | console
     demo: com.ws.framework.activivemq.ActiveMqDemo
     集群:
        MASTER-SLAVE架构,当MASTER宕机时,master所占用的排它锁会立即释放,其中一个slave会获取该排他锁,成为新的master,对外服务;
        扩展: 硬件扩展->垂直扩展(增加集群)->broker拆分(将queue或者topic拆分为多个broker)
     
  垂直化搜索引擎: 针对企业内部的自有数据检索 
     采用NOSQL数据库,无法进行多表关联或者复杂查询问题
    
    
    

            
    
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  