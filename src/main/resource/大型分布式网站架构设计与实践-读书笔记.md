大型分布式网站架构设计与实践(陈康贤)读书笔记(2019-8-10)

知识积累,输入和输出极为重要!

单一应用架构:
	没啥好说的,所有功能都放在同一个进程里;

垂直应用架构 :
	由单一应用架构应变而来,主要是解决了流量的增长,单一机器无法满足性能;
	将原单一的整体进行细度的划分,划分成为各个模块(服务),各模块之间互不干扰;

分布式应用结构:
	由垂直应用架构演变而来,
	业务量的增长,各个服务之间避免不了互相调用,否则不同服务之间存在严重的重叠业务,代码量重复,重复造轮子,
	将业务相同的部分抽取出来独立成为一个服务,以免供彼此之间的互相调用,这样就演变成了分布式应用架构

java中序列化对ObjectOutputStream序列化时,在源代码中需要验证是否序列化如下:
    1.序列化对象是否字符串类型/数组/枚举 -> 如果是走格子的序列化; (底层这些东西都实现了序列化接口)
    2.序列化对象是都实现Serializable接口 ,否则报错 -> NotSerializableException
    3.详情查看ObjectOutputStream 1171行

HTTP : Hypertext Transfer Protocol (超文本传输协议)缩写   
    
网络接口层 -> IP(网络层) -> TCP(传输层) -> HTTP(应用层)

HTTP请求与响应步骤: http://www.google.com:80/index.html
    1.浏览器根据使用的HTTP协议,解析出url对应的域名;
    2.DNS通过域名解析,得到该域名对应的IP地址;
    3.通过url解析出对应端口号(80默认省略)
    4.浏览器发起并建立127.0.0.1:80端口的连接(三次握手);
    5.浏览器向服务器发送GET请求
    6.服务器响应浏览器请求,浏览器读取响应,并渲染网页;
    7.浏览器关闭与服务器的连接;

负载均衡常见算法:
    1.轮询法(牺牲性能)
    2.随机法(若使用轮询法,建议使用随机法替换)
    3.源地址哈希法 通过计算IP的哈希值对服务数量进行取模得到服务地址.使用此算法,在服务不变的情况下,每次的请求都会映射到同一个服务;
        根据此特性,可以在服务消费者和服务提供者之间建立有状态的session会话;
    4.加权轮询法 一般用于服务存在高配和低配配置的情况下
    5.加权随机法
    6.最小连接数法
    
  HTTP未加密的明文
  网关的作用: 接收各种HTTP请求,完成对应的权限与安全校验;
  
  分布式系统基础设施:
    分布式协作及配置管理系统Zookeeper
    分布式缓存系统
       高并发环境下,减轻数据库的压力,提高系统的响应速度和并发吞吐量;
    持久化存储
    分布式消息系统
    搜索引擎
    CDN系统
    负载均衡系统
    日志收集系统
    监控系统
    数据仓库等等
    
  分布式缓存: 
    memcache key-value 时间复杂度O(1) 数据类型多元化(参考redis)
    基于TCP协议之上的memcache协议通信,协议支持两种数据的传递:
        1.文本行  主要用来承载客户端的的命令以及服务端的响应
        2.非结构化数据 使用字节流的形式在客户端和服务端之间进行传输和存储
    LRU算法 : Least Recently Used : 将最近不常访问的数据剔除 ; mybatis的二级缓存默认也是使用LRU(链表+hash);
  分布式session:
    1.持久化到DB 可以保证宕机是会话不易丢失,然后系统的整体吞吐量影响大
    2.session统一存储在缓存集群 可以保证较高的读,写性能;session的时效性和缓存的失效机制很好利用; 
    
  memcached-session-manager : 
    开源高可用的Tomcat session共享解决方案(其实就是替换tomcat默认的session管理器,tomcat默认的session管理器的实现类是StandardManager);
    替换tomcat session管理器只需要在context.xml中增加一个节点配置;
        <Context>
            <Manager pathname="实现类的全限定类名" />
        </Context>
    两种模式:
        Sticky模式 : 
            每次请求都会被映射到同一台后端web server,直到该服务器宕机,这样就可以将session先存放web server本地,等到请求完成后在同步到memcache服务器;
            当web server宕机时,请求被映射到其他web server,这时候,其他web server可以从memcache server中恢复session;
        Non-Sticky模式 :
            每次请求映射的web server是不确定的,每次请求都从memcache获取session,请求处理完毕时,重新将session放入memcache;
       
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  