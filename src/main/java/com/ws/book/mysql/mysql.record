使用mysql定时任务及使用存储函数

mysql:
	查看是否开启事件 : show variables like 'event_scheduler';
	设置开启:
			set global event_scheduler = on;
			set @@global.event_scheduler = on;
			set global event_scheduler = 1;
			set @@global.event_scheduler = 1;
	删除事件: drop event if exists `事件名称`;
			  drop event test2_insert_5_minute;
	查看事件: show events;
	创建事件:
		案例1:
			drop event if exists `test_event`; -- 删除事件
			delimiter ;; -- 分隔符
			create definer=`root`@`localhost` event `test_event` on schedule every 1 second starts '2018-06-20 20:00:00' on completion preserve enable
			do
			    begin
			    	insert into user(name, age,sex) values('ws',18,'男'); --需要执行的sql任务
			    end
			;;
			delimiter ;
		案列2:
			create event if not exists test_event2 -- 事件名称
			on schedule every 1 second starts '2019-11-20 00:00:00'  -- 指定事件从11-20开始,间隔1秒执行
			on completion preserve	-- 执行完毕是否删除事件,此处是不删除该事件
			enable -- 启用事件
			do insert into user(name, age,sex) values('ws',18,'男');	-- 执行的业务逻辑(也可以直接调用存储过程)
	关闭事件
		alter event test_event disable;
	开启事件
		alter event test_event enable;
	存储过程
		delimiter ;;  --指定分隔符
		drop procedure if exists test_event5 ;;
		create procedure test_event4()
         begin
			declare i int default 0;
			while i<100 do
               insert into user(name,age,sex) values('ws',10,'男');
               set i=i+1;
			end while;
		 end ;;
	查看所有存储函数:
		show procedure status;
	事件调用存储过程:
		create event e1 on schedule every 1 week
		do call 存储过程名称(参数);
	调用存储过程:
		call 存储过程名称

    创建插入数据函数:
        delimiter $$
        drop function if exists addNum $$
        create function addNum(begin_num int,end_num int) returns int(10)
        begin

            while begin_num < end_num do
        	insert into user(age,name,sex) values(begin_num,'ws','男');
                set begin_num = begin_num + 1;
            end while;
            return begin_num;
        end $$
        delimiter ;
    调用函数: select addNum(100,6000)

SQL执行顺序:
    MySQL的语句一共分为11步,其中每一个操作都会产生一张虚拟的表，这个虚拟的表作为一个处理的输入，只是这些虚拟的表对用户来说是透明的，但是只有最后一个虚拟的表才会被作为结果返回。
    如果没有在语句中指定对应的操作，那么将会跳过相应的步骤。
       SELECT
       DISTINCT <select_list>
       FROM <left_table>
       <join_type> JOIN <right_table>
       ON <join_condition>
       WHERE <where_condition>
       GROUP BY <group_by_list>
       HAVING <having_condition>
       ORDER BY <order_by_condition>
       LIMIT <limit_number>

    1.FORM: 对FROM的左边的表和右边的表计算笛卡尔积。产生虚表VT1
    2.ON: 对虚表VT1进行ON筛选，只有那些符合<join-condition>的行才会被记录在虚表VT2中。
    3.JOIN: 如果指定了OUTER JOIN（比如left join、 right join），那么保留表中未匹配的行就会作为外部行添加到虚拟表VT2中，产生虚拟表VT3, rug from子句中包含两个以上的表的话，那么就会对上一个join连接产生的结果VT3和下一个表重复执行步骤1~3这三个步骤，一直到处理完所有的表为止。
    4.WHERE: 对虚拟表VT3进行WHERE条件过滤。只有符合<where-condition>的记录才会被插入到虚拟表VT4中。
    5.GROUP BY: 根据group by子句中的列，对VT4中的记录进行分组操作，产生VT5.
    6.CUBE | ROLLUP: 对表VT5进行cube或者rollup操作，产生表VT6.
    7.HAVING: 对虚拟表VT6应用having过滤，只有符合<having-condition>的记录才会被 插入到虚拟表VT7中。
    8.SELECT: 执行select操作，选择指定的列，插入到虚拟表VT8中。
    9.DISTINCT: 对VT8中的记录进行去重。产生虚拟表VT9.
    10.ORDER BY: 将虚拟表VT9中的记录按照<order_by_list>进行排序操作，产生虚拟表VT10.
    11.LIMIT: 取出指定行的记录，产生虚拟表VT11, 并将结果返回。
------------------------------------------------------------------------------------------------------------------------
选择优化的数据类型:
    更小的通常更好。
        一般情况下，应该尽量使用可以正确存储数据的最小数据类型生!。更小的數据类型通常更快，因为它们占用更少的磁盘、内存和CPU缓存，并且处理时需要的CPU周
        期也更少;例如只需要存0-200，tinyint unsigned更好;
    简单就好
        简单数据类型的操作通常需要更少的CPU周期。例如，整型比字符操作代价更低，因为字符集和校对规则(排序规则)使字符比较比整型比较更复杂。
    尽量避免NULL
        通常情况下最好指定列为NOT NULL, 除非真的需要存储NULL值。
        如果查询中包含可为NULL的列，对MySQL来说更难优化，因为可为NULL的列使得索引、索引统计和值比较都更复杂。可为NULL的列会使用更多的存储空间，在
        MySQL里也需要特殊处理。当可为NULL的列被索引时，每个索引记录需要一个额外的字节，在MyISAM里甚至还可能导致固定大小的索引(例如只有一个整数列的
        索引)变成可变大小的索引。通常把可为NULL的列改为NOT NULL 带来的性能提升比较小，所以(调优时)没有必要首先在现有schema中查找并修改掉这种情况，
        除非确定这会导致问题。InnoDB使用单独的位(bit)存储NULL值，所以对于稀疏数据生4有很好的空间效率。但这一点不适用于MyISAM。

    很多MySQL的数据类型可以存储相同类型的数据，只是存储的长度和范围不一样、允许的精度不同，或者需要的物理空间( 磁盘和内存空间)不同。
    相同大类型的不同子类型数据有时也有些特殊的行为和属性。

整数类型
    有两种类型的数字:整数(whole number)和实数(real number)。如果存储整数，可以使用这几种整数类型: TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT。
分别使用8,16, 24, 32，64位存储空间。它们可以存储的值的范围从2(N-1) 到2(N-1)-1, 其中N是存储空间的位数。
    整数类型有可选的UNSIGNED属性，表示不允许负值，这大致可以使正数的上限提高一倍。
    例如TINYINT. UNSIGNED 可以存储的范围是0-255,而TINYINT的存储范围是-128
    MySQL可以为整数类型指定宽度，例如INT(11)，对大多数应用这是没有意义的:它不会限制值的合法范围,只是规定了MySQL的些交互工具(例如MySQL命令行客户端)
用来显示字符的个数。对于存储和计算来说，INT(1) 和INT(20)是相同的。

实数类型
    实数是带有小数部分的数字。然而，它们不只是为了存储小数部分，也可以使用DECIMAL存储比BIGINT还大的整数。MySQL既支持精确类型，也支持不精确类型。
    DECIMAL类型用于存储精确的小数。在MySQL 5.0和更高版本，DECIMAL 类型支持精确计算。
    浮点类型在存储同样范围的值时，通常比DECIMAL使用更少的空间。FLOAT使用4个字节存储。DOUBLE占用8个字节，相比FLOAT有更高的精度和更大的范围。
    和整数类型一样，能选择的只是存储类型， MySQL使用DOUBLE作为内部浮点计算的类型。

    浮点和DECIMAL类型都可以指定精度。对于DECIMAL列，可以指定小数点前后所允许的最大位数。这会影响列的空间消耗。MySQL 5.0和更高版本将数字打包保存到
    一个二进制字符串中(每4个字节存9个数字)。例如，DECIMAL(18,9) 小数点两边将各存储9个数字，-共使用9个字节:小数点前的数字用4个字节，小数点后的数字
    用4个字节，小数点本身占1个字节。
    因为需要额外的空间和计算开销，所以应该尽量只在对小数进行精确计算时才使用DECIMAL--例如存储财务数据。但在数据量比较大的时候，可以考虑使用BIGINT代替
    DECIMAL,将需要存储的货币单位根据小数的位数乘以相应的倍数即可。

字符串类型
    VARCHAR
        VARCHAR类型用于存储可变长字符串，是最常见的字符串数据类型。它比定长类型更节省空间，因为它仅使用必要的空间(例如，越短的字符串使用越少的空间)。
     有一种情况例外，如果MySQL表使用ROW FORMAT-FIXED 创建的话，每一行都会使用定长存储，这会很浪费空间。
        VARCHAR需要使用1或2个额外字节记录字符串的长度:如果列的最大长度小于或等于255字节，则只使用1个字节表示，否则使用2个字节。假设采用latin1字符集，
    一个VARCHAR(10)的列需要11 个字节的存储空间。VARCHAR( 1000)的列则需要1002个字节，因为需要2个字节存储长度信息。
        VARCHAR节省了存储空间，所以对性能也有帮助。但是，由于行是变长的，在UPDATE时可能使行变得比原来更长，这就导致需要做额外的工作。如果一个行占用
    的空间增长，并且在页内没有更多的空间可以存储，在这种情况下，不同的存储引擎的处理方式是不一样的。

    CHAR
        CHAR类型是定长的: MySQL总是根据定义的字符串长度分配足够的空间。当存储CHAR值时，MySQL会删除所有的末尾空格。
        CHAR值会根据需要采用空格进行填充以方便比较。填充和截取空格的行为在不同存储引擎都是一样的，因为这是在MySQL服务器层进行处理的。
        CHAR适合存储很短的字符串，或者所有值都接近同一个长度。例如，CHAR 非常适合存储密码的MD5值，因为这是一个定长的值。对于经常变更的数据，CHAR
    也比VARCHAR更好，因为定长的CHAR类型不容易产生碎片。对于非常短的列，CHAR比VARCHAR在存储空间上也更有效率。例如用CHAR(1)来存储只有Y和N的值，如果
    采用单字节字符集生只需要一一个字节，但是VARCHAR(1)却需要两个字节，因为还有一个记录长度的额外字节。

    使用VARCHAR(5)和VARCHAR(200)存储'hello'的空间开销是一样的。那么使用更短的列有什么优势吗?
    事实证明有很大的优势。更长的列会消耗更多的内存，因为MySQL通常会分配固定大小的内存块来保存内部值。尤其是使用内存临时表进行排序或操作时会特别糟
    糕。在利用磁盘临时表进行排序时也同样糟糕。所以最好的策略是只分配真正需要的空间。

    BLOB和TEXT类型
        BLOB和TEXT都是为存储很大的数据而设计的字符串数据类型，分别采用二进制和字符方式存储。

    使用枚举(ENUM) 代替字符串类型
        有时候可以使用枚举列代替常用的字符串类型。枚举列可以把一些不重复的字符串存储成一个预定义的集合。MySQL在存储枚举时非常紧凑，会根据列表值的
    数量压缩到一个或者两个字节中。MySQL在内部会将每个值在列表中的位置保存为整数，并且在表的frm文件中保存“数字-字符串”映射关系的“ 查找表”。
        create table test_enum (
          sex enum('男','女 ') not null  --建立对应的数字映射字符串关系 1->男,2->女
        );
        insert into test_enum (sex) values('女'),('男');
        插入的数据实际存储为整数，而不是字符串。查询如下可知: select sex + 0 from test_enum; 结果 为 2 , 1
        枚举字段是按照内部存储的整数而不是定义的字符串进行排序的:
        尽量避免使用数字作为枚举值,因为这样双重性质会导致混乱;

日期和时间类型
    DATETIME
        这个类型能保存大范围的值，从1001年到9999年，精度为秒。它把日期和时间封装到格式为YYY Y MMDDHHMMSS的整数中，与时区无关。使用8个字节的存储
    空间。默认情况下，MySQL以一种可排序的、无歧义的格式显示DATETIME值，例如 “2008-01-16 22:37:08”。这是ANSI标准定义的日期和时间表示方法。

    TIMESTAMP
        TIMESTAMP类型保存了从1970年1月1日午夜(格林尼治标准时间)以来的秒数，它和UNIX时间戳相同。TIMESTAMP 只使用4个字节的存储空间，因此它的范围比
    DATETIME小得多:只能表示从1970年到2038年。MySQL提供了from unixtime()函数把unix时间戳转换为日期，并提供了unix timestamp()函数把日期转换为unix时间戳。
        TIMESTAMP列默认为NOT NULL。

    如果在多个时区存储或访问数据，TIMESTAMP 和DATETIME的行为将很不一样。前者提供的值与时区有关系，后者则保留文本表示的日期和时间。
    除了特殊行为之外，通常也应该尽量使用TIMESTAMP,因为它比DATETIME空间效率更高。有时候人们会将Unix时间截存储为整数值，但这不会带来任何收益。用整数保存
    时间截的格式通常不方便处理，不推荐这样做。

位数据类型
    BIT
    SET

特殊类型:
    经常使用VARCHAR(15)列来存储IP地址。然而，它们实际上是32位无符号整数，不是字符串。用小数点将地址分成四段的表示方法只是为了让人们阅读容易。所以应该
    用无符号整数存储IP地址。MySQL提供INET ATON()和INET NTOA() 函数在这两种表示方法之间转换。
    SELECT INET_ATON("192.18.0.92") : 将IP转成数字
    SELECT INET_NTOA(3222405212) :    将数字转为IP
------------------------------------------------------------------------------------------------------------------------
提高alter table速度
    修改列默认值语句(如果数据量很大,需要更改所有的表数据,这时候速度不理想):
        ALTER TABLE ws.`test_enum` MODIFY COLUMN age TINYINT(3) NOT NULL DEFAULT 5;
    使用另一种方式提高速度:
        ALTER TABLE ws.`test_enum` ALTER COLUMN age SET DEFAULT 10;
        这个语句会直接修改frm文件而不涉及表数据。

------------------------------------------------------------------------------------------------------------------------
创建高性能的索引:
    在MySQL中，索引是在存储引擎层而不是服务器层实现的。所以，并没有统一的索引标准;

  B-Tree索引
    当人们谈论索引的时候，如果没有特别指明类型，那多半说的是B-Tree索引，它使用B-Tree数据结构来存储数据生;InnoDB则使用的是B+Tree

  哈希索引
    哈希索引(hash index)基于哈希表实现，只有精确匹配索引所有列的查询才有效生。对于每一行数据，存储引擎都会对所有的索引列计算一个
哈希码(hashcode)，哈希码是一个较小的值，并且不同键值的行计算出来的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在哈
希表中保存指向每个数据行的指针。

  空间数据索引(R-Tree)

  全文索引:
    全文索引是一种特殊类型的索引，它查找的是文本中的关键词，而不是直接比较索引中的值。全文搜索和其他几类索引的匹配方式完全不样。
它有许多需要注意的细节，如停用词、词干和复数、布尔搜索等。全文索引更类似于搜索引擎做的事情，而不是简单的WHERE条件匹配。
    在相同的列上同时创建全文索引和基于值的B-Tree索引不会有冲突，全文索引适用于MATCH AGAINST 操作，而不是普通的WHERE条件操作。

  索引的优点:
    1.索引大大减少了服务器需要扫描的数据量。
    2.索引可以帮助服务器避免排序和临时表。
    3.索引可以将随机I/O变为顺序I/O。

  建立单列索引: create table xxx ( id int not null , age tinyint not null , key(id) , key(age));
  建立多列索引: create table xxx(id int not null, age tinyint not null, key(id,age));

  MyISAM中主键索引和其他索引在结构上没有什么不同。主键索引就是一个名为PRIMARY的唯一非空索引。





------------------------------------------------------------------------------------------------------------------------



