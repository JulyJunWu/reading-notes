从广义上讲，Clojure、 JRuby、 Groovy 等运行于Java虚拟机上的语言及其相关的程序都属于Java技术体系的-员。

我们可以把Java程序设计语言、Java 虚拟机、Java API类库这三部分统称为JDK(Java Development Kit)，JDK是用于支持Java程序开发的最小环境;

可以把Java API类库中的Java SE API子集和Java虚拟机这两部分统称为JRE (Java Runtime Environment)，JRE是支持Java程序运行的标准环境。

Java技术体系可以分为四个平台，分别为:
    1.Java Card:支持一些 Java小程序(Applets)运行在小内存设备 (如智能卡) 上的平台。
    2.Java ME( Micro Edition):支持Java程序运行在移动终端(手机、PDA)上的平台，对Java API有所精简，并加入了针对移动终端的支持，这个版本以前称为J2ME。
    3.JavaSE(Standard Edition):支持面向桌面级应用(如Windows下的应用程序)的Java平台，提供了完整的Java核心API,这个版本以前称为J2SE。
    4.Java EE (Enterprise Edition):支持使用多层架构的企业应用( 如ERP、CRM应用)的Java平台，除了提供JavaSEAPI外，还对其做了大量的扩充并提供了相关的
部署支持，这个版本以前称为J2EE。

Java语言的前身: Oak (橡树)。

1995年5月23日，Oak语言改名为Java,并且在SunWorld大会上正式发布了Java 1.0版本。Java 语言第一-次提出了“Write Once, Run Anywhere”的口号。

Scala、Clojure 及Erlang等天生就具备并行计算能力的语言。

在JDK1.6 Update 14之后，提供了普通对象指针压缩功能(-XX:+ UseCompressedOops)，在解释器解释字节码时，植入压缩指令以节省内存消耗。

运行时数据区: 查看运行时数据区.png
  程序计数器:
    程序计数器( Program Counter Register)是一块较小的内存空间，它的作用可以看做是`当前线程所执行的字节码的行号指示器。`在虚拟机的概念模型里(仅是概念模型，各种虚拟机可能会通过-些更高效的方式去实现)，字节码解释器工作时就是通过改变这个计数器的值来选取下-条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来成。
    由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器(对于多核处理器来说是一一个内核)只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“`线程私有`”的内存。
    如果线程正在执行的是一一个Java方法，`这个计数器记录的是正在执行的虚拟机字节码指令的地址`;如果正在执行的是Native方法，`这个计数器值则为空(Undefined)`。此内存区域是唯一一个在Java虚拟机规范中`没有规定任何OutOfMemoryError情况的区域`。
    
  Java虚拟机栈(Java Virtual Machine Stacks)
    线程私有的,生命周期与线程相同。`虚拟机栈描述的是Java方法执行的内存模型`:每个方法被执行的时候都会同时创建一个`栈帧`(Stack Frame”)用于`存储局部变量表、操作栈、动态链接、
方法出口等`信息。`每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。`
    局部变量表存放了编译期可知的各种基本数据类型(boolean、 byte、 char、 short、 int、float、long、 double)、 对象引用(reference 类型，它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的`引用指针`，也可能指向一个代表对象的`句柄`或者其他与此对象相关的位置)`和returnAddress类型`(指向了一条字节码指令的地址)。
    64位长度的long和double类型的数据会占用2个`局部变量空间(Slot)`,其余的数据类型只占用1个。`局部变量表所需的内存空间在编译期间完成分配`，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，`在方法运行期间不会改变局部变量表的大小。`
     两种异常: 
        1.如果线程请求的栈深度大于虚拟机所允许的深度，将抛出`StackOverflowError`异常;
        2.如果虚拟机栈可以动态扩展(当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈)，当扩展时无法申请到足够的内存时会抛出`OutOfMemoryError`异常。
     栈帧是方法运行期的基础数据结构，

  本地方法栈(Native Method Stacks):
    与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法(也就是字节码)服务，而`本地方法栈则是为虚拟机使用到的Native方法服务`。虚拟机规范中对本地方法栈中的方法使用的语
言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机(譬如Sun HotSpot虚拟机)直接就把本地方法栈和虚拟机栈合二为一。
    `本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。`

 Java堆:
     对于大多数应用来说，Java堆(JavaHeap)是Java虚拟机所管理的内存中最大的一块。
     1.Java堆是`被所有线程共享`的一块内存区域，`在虚拟机启动时创建`。
     2.`此内存区域的唯一目的就是存放对象实例`，几乎所有的对象实例都在这里分配内存。这一点在Java虚拟机规范中的描述是:所有的对象实例以及数组都要在堆上分配”，但是随着JIT编译器的发展与`逃逸分析技术`的逐渐成熟，`栈上分配、标量替换`优化技术将会导致-些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。
     3.采用分代回收算法
     4.会出现OutOfMemoryError;
     Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆”(Garbage Collected Heap)。如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java堆中还可以细分为:`新生代和老年代`;再细致一点的有`Eden`空间、`From Survivor空间、To Survivor`空间等。如果从内存分配的角度看，线程共享的Java堆中可能划分出多个线程私有的`分配缓冲区`(ThreadLocalAllocation Buffer, TLAB)。 不过，无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例，进步划分的目的是为了更好地回收内存，或者更快地分配内存。
     -Xms , -Xmx
 
 方法区(Method Area):
    1.线程共享的内存区域
    2.用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。(Non-Heap (非堆))
    3.当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。
    4.垃圾回收器对这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载
    对于HotSpot很多人愿意把方法区称为“永久代”( Permanent Generation)，本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已。对于其他虚拟机来说是不存在永久代的概念的;
     Java虚拟机规范对这个区域的限制非常宽松，除了和Java堆样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字-样“永久”存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是有必要的。

 运行时常量池(Runtime Constant Pool):
    1.方法区的一部分。
    2.当常量池无法再申请到内存时会抛出OutOfMemoryError异常。
    Class文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池( Constant Pool Table)，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。
    对于运行时常量池，Java虚拟机规范没有做任何细节的要求，不同的提供商实现的虚拟机可以按照自己的需要来实现这个内存区域。不过，一般来说，除了保存Class文件中描述的符号引用外，还会把翻译出来的接引用也存储在运行时常量池中。
    运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只能在编译期产生，也就是并非预置人Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String 类的intern()方法。

 直接内存(Direct Memory):
    并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现.
    在JDK 1.4中新加入了NIO (New Input/Output)类，引入了一种基于通道(Channel)与缓冲区(Buffer) 的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。
    本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存(包括RAM及SWAP区或者分页文件)的大小及处理器寻址空间的限制。服务器管理员配置虚拟机参数时，一般会根据实际内存设置-Xmx等参数信息，但经常会忽略掉直接内存，使得各个内存区域的总和大于物理内存限制(包括物理上的和操作系统级的限制)，从而导致动态扩展时出现OutOfMemoryError异常。

 对象访问 : Object obj = new Object() 出现在方法体中;
    1.Object obj这部分的语义将会反映到Java栈的本地变量表中，作为一个reference 类型数据出现。
    2.new Object()这部分的语义将会反映到Java堆中，形成块存储了Object类型所有实例数据值(Instance Data,对象中各个实例字段的数据)的结构化内存，根据具体类型以及虚拟机实现的对象内存布局(Object Memory Layout)的不同，这块内存的长度是不固定的。另外，在Java堆中还必须包含能查找到此对象类型数据(如对象类型、父类、实现的接口、方法等)的地址信息，这些类型数据则存储在方法区中。
   不同虚拟机实现的对象访问方式会有所不同，主流的访问方式有两种:使用`句柄`和`直接指针`。
      1.如果使用句柄访问方式，Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息(句柄访问对象.png)。
      2.如果使用直接指针访问方式，Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference中直接存储的就是对象地址(直接指针访问对象.png)。
   这两种对象的访问方式各有优势:
        1.使用句柄访问方式的最大好处就是reference 中存储的是稳定的句柄地址，在对象被移动(垃圾收集时移动对象是非常普遍的行为)时只会改变句柄中的实例数据指针，而reference本身不需要被修改。
        2.使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。
        Sun HotSpot使用第二种方式进行对象访问;
 判断对象是否存活的算法:
    1.引用计数法
        给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1 ;当引用失效时，计数器值就减1 ;任何时刻计数器都为0的对象就是不可能再被使用的。
        引用计数算法(ReferenceCounting)的实现简单，判定效率也很高，但是`难以解决对象之间的相互循环引用的问题`。
    2.根搜索算法
        用根搜索算法(GC Roots Tracing)判定对象是否存活的。这个算法的基本思路就是通过一系列的名为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链( Reference Chain),当一个对象到GC Roots没有任何引用链相(用图论的话来说就是从GC Roots到这个对象不可达)时，则证明此对象是不可用的。
    在Java语言里，可作为GCRoots的对象包括下面几种:
        1.虚拟机栈(栈帧中的本地变量表)中的引用的对象。
        2.方法区中的类静态属性引用的对象。
        3.方法区中的常量引用的对象。
        4.本地方法栈中JNI (即一般说的Native方法)的引用的对象。
        
 在JDK1.2之后，Java对引用的概念进行了扩充，将引用分为强引用(Strong Reference)、软引用(Soft Reference)、弱引用( Weak Reference)、 虚引用( PhantomReference)四种，这四种引用强度依次逐渐减弱。
   1.`强引用`就是指在程序代码之中普遍存在的，类似“Object obj = new Objct()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。
   2.`软引用`用来描述- -些还有用，但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中并进行第二次回收。如果这次回收还是没有足够的内存，才会抛出内存溢出异常。在JDK1.2之后，提供了SoftReference类来实现软引用。
   3.`弱引用`也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2之后，提供了WeakReference类来实现弱引用。
   4.`虚引用`也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯目的就是希望能在这个对象被收集器回收时收到-一个系统通知。在JDK 1.2之后，提供了PhantomReference 类来实现虚引用。
 
 搜索算法回收对象的过程:
    在根搜索算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于 “缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程:如果对象在进行根搜索后发现没有与GC Roots相连接的引用链，那它将会被第次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。
    如果这个对象被判定为有必要执行finalize() 方法，那么这个对象将会被放置在-一个名为F-Queue的队列之中，并在稍后由一条由虚拟机自动建立的、低优先级的Finalizer线程去执行。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束。这样做的原因是，如果一个对象在finalize()方法中执行缓慢，或者发生了死循环(更极端的情况)，将很可能会导致F-Queue队列中的其他对象永久处于等待状态甚至导致整个内存回收系统崩溃。finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己一只要重新与引用链上的任何一个对象建立关联即可，譬如把自己(this关键字)赋值给某个类变量或对象的成员变量，那在第二次标记时它将被移除出“即将回收”的集合;如果对象这时候还没有逃脱，那它就真的离死不远了。
    另外一个值得注意的地方就是，`任何一个对象的finalize()方法都只会被系统自动调用一次`，如果对象面临下一次回收，它的finalize()方法不会被再次执行;
    
 如何判断一个类是否“无用的类":
    1.该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。
    2.加载该类的ClassLoader已经被回收。
    3.该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
    HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用
    -verbose:class : 查看类的是由哪个类加载器加载
    -XX:+TraceClassLoading : 查看类的加载
    -XX:+TraceClassUnLoading :查看类的卸载信息。

 垃圾收集算法:
     1.标记-清除算法
        最基础的收集算法是“标记-清除”(Mark-Sweep) 算法，如它的名字样，算法分 为“标记”和“清除”两个阶段:首先标记出所有需要回收的对象，在标记完成后统回收掉所有被标记的对象，它的标记过程其实在前之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其缺点进行改进而得到的。
        它的主要缺点有两个:
            一个是效率问题，标记和清除过程的效率都不高;
            另外一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而得不提前触发另一次垃圾收集动作。
     2.复制算法
        为了解决效率问题，一种称为“复制”(Copying)的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的-块。当这块的内存用完了，就将还存活着的对象复制到另外块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对其中的块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为原来的半，未免太高了一点。
        现在的商业虚拟机都采用这种收集算法来回收新生代，IBM的专门研究表明，新生代中的对象98%是朝生夕死的，所以并不需要按照1 :1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较Survivor空间，每次使用Eden和其中的一块Survivor”。当回收时，将Eden和Survivor中还存活着的对象一次性地拷贝到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor的空间。HotSpot虚拟
机默认Eden和Survivor的大小比例是8:1,也就是每次新生代中可用内存空间为整个新生代容量的90% ( 80%+10%)，只有10%的内存是会被“浪费”的。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存(这里指老年代)进行分配担保(Handle Promotion)。
    3.标记一整理算法
        复制收集算法在对象存活率较高时就要执行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。根据老年代的特点，有人提出了另外一种“标记-整理”(Mark-Compact)算法，标记过程仍然与“标记一清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存;
    4.分代收集算法
    当前商业虚拟机的垃圾收集都采用“分代收集”(Generational Collection)算法，种算法并没有什么新的思想，只是根据对象的存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记一清理”或“标记一整理”算法来进行回收。

 垃圾收集器:
    1.Serial收集器
      Serial收集器是最基本、历史最悠久的收集器，曾经(在JDK 1.3.1 之前)是虚拟机新生代收集的唯一选择。 大家看名字就知道，这个收集器是-一个单线程的收集器，但它的“单线程”的意义并不仅仅是说明它只会使用一一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程(Sun将这件事情称之为“Stop The World")，直到它收集结束。
      它也有着优于其他收集器的地方:简单而高效(与其他收集器的单线程比),对于限定单个CPU的环境来说，Serial 收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。在用户的桌面应用场景中，分配给虚拟机管理的内存一般来说不会很大，收集几十兆甚至一两百兆的新生代(仅仅是新生代使用的内存，桌面应用基本上不会再大了),停顿时间完全可以控制在几十毫秒最多一百多毫秒以内，只要不是频繁发生，这点停顿是可以接受的。所以，Serial 收集器对于运行在Client模式下的虚拟机来说是一个很好的选择。
    2.ParNew收集器
      ParNew收集器其实就是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为包括Serial收集器可用的所有控制参数(例如: -XX:SurvivorRatio、-XX:PretenureSizeThreshold、-XX:HandlePromotionFailure等 )、收集算法、Stop TheWorld、对象分配规则、回收策略等都与Serial收集器完全样，实现上这两种收集器也共用了相当多的代码。
      ParNew收集器除了多线程收集之外，其他与Serial收集器相比并没有太多创新之处，但它却是许多运行在Server模式下的虚拟机中首选的新生代收集器，其中有一个与性能无关但很重要的原因是，除了Serial收集器外，目前只有它能与CMS收集器配合工作。
      ParNew收集器也是使用-XX:+UseConcMarkSweepGC选项后的默认新生代收集器，也可以使用-XX:+UseParNewGC.选项来强制指定它。
      ParNew收集器在单CPU的环境中绝对不会有比Serial收集器更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个CPU的环境中都不能百分之百地保证能超越Serial收集器。当然，随着可以使用的CPU的数量的增加，它对于GC时系统资源的利用还是很有好处的。它默认开启的收集线程数与CPU的数量相同，在CPU非常多(譬如32个，现在CPU动辄就4核加超线程，服务器超过32个逻辑CPU的情况越来越多了)的环境下，可以使用-XX:ParallelGCThreads 参数来限制垃圾收集的线程数。
    3.ParallelScavenge收集器
        也是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器.....
        CMS等收集器的关注点尽可能地缩短垃圾收集时用户线程的停顿时间，而ParallelScavenge收集器的目标则是达到-一个可控制的吞吐量(Throughput)。
        所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)，虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户的体验;而高吞吐量则可以最高效率地利用CPU时间，尽快地完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。
        Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的-XX:MaxGCPauseMillis参数及直接设置吞吐量大小的-XX:GCTimeRatio参数。
    4.Serial Old收集器
      Serial Old是Serial 收集器的老年代版本，它同样是一个单线程收集器，使用“标记一整理”算法。这个收集器的主要意义也是被Client模式下的虚拟机使用。如果在Server模式下，它主要还有两大用途:一个是在JDK 1.5及之前的版本中与ParallelScavenge收集器搭配使用，另外一个就是作为CMS收集器的后备预案，在并发收集发生ConcurrentModeFailure的时候使用。
    5.Parallel Old收集器
      Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法.
      “吞吐量优先”收集器终于有了比较名副其实的应用组合，在注重吞吐量及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。
    6.CMS (Concurrent Mark Sweep)收集器
      是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用都集中在互联网站或B/S系统的服务端上,这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。
      从名字(包含“Mark Sweep")上就可以看出CMS收集器是基于“标记一清除”算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为4个步骤，包括:
        1.初始标记(CMS initial mark)
        2.并发标记( CMS concurrent mark)
        3.重新标记( CMS remark)
        4.并发清除(CMS concurrent sweep)
      其中初始标记、重新标记这两个步骤仍然需要“StopTheWorld"。初始标记仅仅只是标记一下GCRoots能直接关联到的对象，速度很快，并发标记阶段就是进行GCRootsTracing的过程，而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那--部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。
    三个显著缺点:
        1.对CPU资源非常敏感; 默认启动的回收线程数量 = (cpu数量+3)/4 ,当cu不足4个时,会导致用户线程变慢;
        2.无法处理浮动垃圾(Floating Garbage)
        3.产生大量碎片空间(因为是基于标准-清除算法);为了解决这个问题，CMS收集器提供了一个-XX:+UseCMSCompactAtFullCollection开关参数，用于在“享受”完FullGC服务之后额外免费附送一个碎片整理过程，内存整理的过程是无法并发的。空间碎片问题没有了，但停顿时间不得不变长了。虚拟机设计者们还提供了另外一个参数-XX: CMSFullGCsBeforeCompaction,这个参数用于设置在执行多少次不压缩的Full GC后，跟着来一次带压缩的。





    
 





    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    