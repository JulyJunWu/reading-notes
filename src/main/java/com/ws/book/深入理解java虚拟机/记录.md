从广义上讲，Clojure、 JRuby、 Groovy 等运行于Java虚拟机上的语言及其相关的程序都属于Java技术体系的-员。

我们可以把Java程序设计语言、Java 虚拟机、Java API类库这三部分统称为JDK(Java Development Kit)，JDK是用于支持Java程序开发的最小环境;

可以把Java API类库中的Java SE API子集和Java虚拟机这两部分统称为JRE (Java Runtime Environment)，JRE是支持Java程序运行的标准环境。

Java技术体系可以分为四个平台，分别为:
    1.Java Card:支持一些 Java小程序(Applets)运行在小内存设备 (如智能卡) 上的平台。
    2.Java ME( Micro Edition):支持Java程序运行在移动终端(手机、PDA)上的平台，对Java API有所精简，并加入了针对移动终端的支持，这个版本以前称为J2ME。
    3.JavaSE(Standard Edition):支持面向桌面级应用(如Windows下的应用程序)的Java平台，提供了完整的Java核心API,这个版本以前称为J2SE。
    4.Java EE (Enterprise Edition):支持使用多层架构的企业应用( 如ERP、CRM应用)的Java平台，除了提供JavaSEAPI外，还对其做了大量的扩充并提供了相关的
部署支持，这个版本以前称为J2EE。

Java语言的前身: Oak (橡树)。

1995年5月23日，Oak语言改名为Java,并且在SunWorld大会上正式发布了Java 1.0版本。Java 语言第一-次提出了“Write Once, Run Anywhere”的口号。

Scala、Clojure 及Erlang等天生就具备并行计算能力的语言。

在JDK1.6 Update 14之后，提供了普通对象指针压缩功能(-XX:+ UseCompressedOops)，在解释器解释字节码时，植入压缩指令以节省内存消耗。

运行时数据区: 查看运行时数据区.png
  程序计数器:
    程序计数器( Program Counter Register)是一块较小的内存空间，它的作用可以看做是`当前线程所执行的字节码的行号指示器。`在虚拟机的概念模型里(仅是概念模型，各种虚拟机可能会通过-些更高效的方式去实现)，字节码解释器工作时就是通过改变这个计数器的值来选取下-条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来成。
    由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器(对于多核处理器来说是一一个内核)只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“`线程私有`”的内存。
    如果线程正在执行的是一一个Java方法，`这个计数器记录的是正在执行的虚拟机字节码指令的地址`;如果正在执行的是Native方法，`这个计数器值则为空(Undefined)`。此内存区域是唯一一个在Java虚拟机规范中`没有规定任何OutOfMemoryError情况的区域`。
    
  Java虚拟机栈(Java Virtual Machine Stacks)
    线程私有的,生命周期与线程相同。`虚拟机栈描述的是Java方法执行的内存模型`:每个方法被执行的时候都会同时创建一个`栈帧`(Stack Frame”)用于`存储局部变量表、操作栈、动态链接、方法出口等`信息。`每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。`
    局部变量表存放了编译期可知的各种基本数据类型(boolean、 byte、 char、 short、 int、float、long、 double)、 对象引用(reference 类型，它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的`引用指针`，也可能指向一个代表对象的`句柄`或者其他与此对象相关的位置)`和returnAddress类型`(指向了一条字节码指令的地址)。
    64位长度的long和double类型的数据会占用2个`局部变量空间(Slot)`,其余的数据类型只占用1个。`局部变量表所需的内存空间在编译期间完成分配`，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，`在方法运行期间不会改变局部变量表的大小。`
     两种异常: 
        1.如果线程请求的栈深度大于虚拟机所允许的深度，将抛出`StackOverflowError`异常;
        2.如果虚拟机栈可以动态扩展(当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈)，当扩展时无法申请到足够的内存时会抛出`OutOfMemoryError`异常。
     栈帧是方法运行期的基础数据结构，

  本地方法栈(Native Method Stacks):
    与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法(也就是字节码)服务，而`本地方法栈则是为虚拟机使用到的Native方法服务`。虚拟机规范中对本地方法栈中的方法使用的语
言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机(譬如Sun HotSpot虚拟机)直接就把本地方法栈和虚拟机栈合二为一。
    `本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。`

 Java堆:
     对于大多数应用来说，Java堆(JavaHeap)是Java虚拟机所管理的内存中最大的一块。
     1.Java堆是`被所有线程共享`的一块内存区域，`在虚拟机启动时创建`。
     2.`此内存区域的唯一目的就是存放对象实例`，几乎所有的对象实例都在这里分配内存。这一点在Java虚拟机规范中的描述是:所有的对象实例以及数组都要在堆上分配”，但是随着JIT编译器的发展与`逃逸分析技术`的逐渐成熟，`栈上分配、标量替换`优化技术将会导致-些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。
     3.采用分代回收算法
     4.会出现OutOfMemoryError;
     Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆”(Garbage Collected Heap)。如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java堆中还可以细分为:`新生代和老年代`;再细致一点的有`Eden`空间、`From Survivor空间、To Survivor`空间等。如果从内存分配的角度看，线程共享的Java堆中可能划分出多个线程私有的`分配缓冲区`(ThreadLocalAllocation Buffer, TLAB)。 不过，无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例，进步划分的目的是为了更好地回收内存，或者更快地分配内存。
     -Xms , -Xmx
 
 方法区(Method Area):
    1.线程共享的内存区域
    2.用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。(Non-Heap (非堆))
    3.当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。
    4.垃圾回收器对这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载
    对于HotSpot很多人愿意把方法区称为“永久代”( Permanent Generation)，本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已。对于其他虚拟机来说是不存在永久代的概念的;
     Java虚拟机规范对这个区域的限制非常宽松，除了和Java堆样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字-样“永久”存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是有必要的。

 运行时常量池(Runtime Constant Pool):
    1.方法区的一部分。
    2.当常量池无法再申请到内存时会抛出OutOfMemoryError异常。
    Class文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池( Constant Pool Table)，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。
    对于运行时常量池，Java虚拟机规范没有做任何细节的要求，不同的提供商实现的虚拟机可以按照自己的需要来实现这个内存区域。不过，一般来说，除了保存Class文件中描述的符号引用外，还会把翻译出来的接引用也存储在运行时常量池中。
    运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只能在编译期产生，也就是并非预置人Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String 类的intern()方法。

 直接内存(Direct Memory):
    并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现.
    在JDK 1.4中新加入了NIO (New Input/Output)类，引入了一种基于通道(Channel)与缓冲区(Buffer) 的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。
    本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存(包括RAM及SWAP区或者分页文件)的大小及处理器寻址空间的限制。服务器管理员配置虚拟机参数时，一般会根据实际内存设置-Xmx等参数信息，但经常会忽略掉直接内存，使得各个内存区域的总和大于物理内存限制(包括物理上的和操作系统级的限制)，从而导致动态扩展时出现OutOfMemoryError异常。

 对象访问 : Object obj = new Object() 出现在方法体中;
    1.Object obj这部分的语义将会反映到Java栈的本地变量表中，作为一个reference 类型数据出现。
    2.new Object()这部分的语义将会反映到Java堆中，形成块存储了Object类型所有实例数据值(Instance Data,对象中各个实例字段的数据)的结构化内存，根据具体类型以及虚拟机实现的对象内存布局(Object Memory Layout)的不同，这块内存的长度是不固定的。另外，在Java堆中还必须包含能查找到此对象类型数据(如对象类型、父类、实现的接口、方法等)的地址信息，这些类型数据则存储在方法区中。
   不同虚拟机实现的对象访问方式会有所不同，主流的访问方式有两种:使用`句柄`和`直接指针`。
      1.如果使用句柄访问方式，Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息(句柄访问对象.png)。
      2.如果使用直接指针访问方式，Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference中直接存储的就是对象地址(直接指针访问对象.png)。
   这两种对象的访问方式各有优势:
        1.使用句柄访问方式的最大好处就是reference 中存储的是稳定的句柄地址，在对象被移动(垃圾收集时移动对象是非常普遍的行为)时只会改变句柄中的实例数据指针，而reference本身不需要被修改。
        2.使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。
        Sun HotSpot使用第二种方式进行对象访问;
 判断对象是否存活的算法:
    1.引用计数法
        给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1 ;当引用失效时，计数器值就减1 ;任何时刻计数器都为0的对象就是不可能再被使用的。
        引用计数算法(ReferenceCounting)的实现简单，判定效率也很高，但是`难以解决对象之间的相互循环引用的问题`。
    2.根搜索算法
        用根搜索算法(GC Roots Tracing)判定对象是否存活的。这个算法的基本思路就是通过一系列的名为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链( Reference Chain),当一个对象到GC Roots没有任何引用链相(用图论的话来说就是从GC Roots到这个对象不可达)时，则证明此对象是不可用的。
    在Java语言里，可作为GCRoots的对象包括下面几种:
        1.虚拟机栈(栈帧中的本地变量表)中的引用的对象。
        2.方法区中的类静态属性引用的对象。
        3.方法区中的常量引用的对象。
        4.本地方法栈中JNI (即一般说的Native方法)的引用的对象。
        
 在JDK1.2之后，Java对引用的概念进行了扩充，将引用分为强引用(Strong Reference)、软引用(Soft Reference)、弱引用( Weak Reference)、 虚引用( PhantomReference)四种，这四种引用强度依次逐渐减弱。
   1.`强引用`就是指在程序代码之中普遍存在的，类似“Object obj = new Objct()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。
   2.`软引用`用来描述- -些还有用，但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中并进行第二次回收。如果这次回收还是没有足够的内存，才会抛出内存溢出异常。在JDK1.2之后，提供了SoftReference类来实现软引用。
   3.`弱引用`也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2之后，提供了WeakReference类来实现弱引用。
   4.`虚引用`也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯目的就是希望能在这个对象被收集器回收时收到-一个系统通知。在JDK 1.2之后，提供了PhantomReference 类来实现虚引用。
 
 搜索算法回收对象的过程:
    在根搜索算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于 “缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程:如果对象在进行根搜索后发现没有与GC Roots相连接的引用链，那它将会被第次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。
    如果这个对象被判定为有必要执行finalize() 方法，那么这个对象将会被放置在-一个名为F-Queue的队列之中，并在稍后由一条由虚拟机自动建立的、低优先级的Finalizer线程去执行。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束。这样做的原因是，如果一个对象在finalize()方法中执行缓慢，或者发生了死循环(更极端的情况)，将很可能会导致F-Queue队列中的其他对象永久处于等待状态甚至导致整个内存回收系统崩溃。finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己一只要重新与引用链上的任何一个对象建立关联即可，譬如把自己(this关键字)赋值给某个类变量或对象的成员变量，那在第二次标记时它将被移除出“即将回收”的集合;如果对象这时候还没有逃脱，那它就真的离死不远了。
    另外一个值得注意的地方就是，`任何一个对象的finalize()方法都只会被系统自动调用一次`，如果对象面临下一次回收，它的finalize()方法不会被再次执行;
    
 如何判断一个类是否“无用的类":
    1.该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。
    2.加载该类的ClassLoader已经被回收。
    3.该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
    HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用
    -verbose:class : 查看类的是由哪个类加载器加载
    -XX:+TraceClassLoading : 查看类的加载
    -XX:+TraceClassUnLoading :查看类的卸载信息。

 垃圾收集算法:
     1.标记-清除算法
        最基础的收集算法是“标记-清除”(Mark-Sweep) 算法，如它的名字样，算法分 为“标记”和“清除”两个阶段:首先标记出所有需要回收的对象，在标记完成后统回收掉所有被标记的对象，它的标记过程其实在前之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其缺点进行改进而得到的。
        它的主要缺点有两个:
            一个是效率问题，标记和清除过程的效率都不高;
            另外一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而得不提前触发另一次垃圾收集动作。
     2.复制算法
        为了解决效率问题，一种称为“复制”(Copying)的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的-块。当这块的内存用完了，就将还存活着的对象复制到另外块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对其中的块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为原来的半，未免太高了一点。
        现在的商业虚拟机都采用这种收集算法来回收新生代，IBM的专门研究表明，新生代中的对象98%是朝生夕死的，所以并不需要按照1 :1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较Survivor空间，每次使用Eden和其中的一块Survivor”。当回收时，将Eden和Survivor中还存活着的对象一次性地拷贝到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor的空间。HotSpot虚拟
机默认Eden和Survivor的大小比例是8:1,也就是每次新生代中可用内存空间为整个新生代容量的90% ( 80%+10%)，只有10%的内存是会被“浪费”的。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存(这里指老年代)进行分配担保(Handle Promotion)。
    3.标记一整理算法
        复制收集算法在对象存活率较高时就要执行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。根据老年代的特点，有人提出了另外一种“标记-整理”(Mark-Compact)算法，标记过程仍然与“标记一清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存;
    4.分代收集算法
    当前商业虚拟机的垃圾收集都采用“分代收集”(Generational Collection)算法，种算法并没有什么新的思想，只是根据对象的存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记一清理”或“标记一整理”算法来进行回收。

 垃圾收集器:
    1.Serial收集器
      Serial收集器是最基本、历史最悠久的收集器，曾经(在JDK 1.3.1 之前)是虚拟机新生代收集的唯一选择。 大家看名字就知道，这个收集器是-一个单线程的收集器，但它的“单线程”的意义并不仅仅是说明它只会使用一一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程(Sun将这件事情称之为“Stop The World")，直到它收集结束。
      它也有着优于其他收集器的地方:简单而高效(与其他收集器的单线程比),对于限定单个CPU的环境来说，Serial 收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。在用户的桌面应用场景中，分配给虚拟机管理的内存一般来说不会很大，收集几十兆甚至一两百兆的新生代(仅仅是新生代使用的内存，桌面应用基本上不会再大了),停顿时间完全可以控制在几十毫秒最多一百多毫秒以内，只要不是频繁发生，这点停顿是可以接受的。所以，Serial 收集器对于运行在Client模式下的虚拟机来说是一个很好的选择。
    2.ParNew收集器
      ParNew收集器其实就是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为包括Serial收集器可用的所有控制参数(例如: -XX:SurvivorRatio、-XX:PretenureSizeThreshold、-XX:HandlePromotionFailure等 )、收集算法、Stop TheWorld、对象分配规则、回收策略等都与Serial收集器完全样，实现上这两种收集器也共用了相当多的代码。
      ParNew收集器除了多线程收集之外，其他与Serial收集器相比并没有太多创新之处，但它却是许多运行在Server模式下的虚拟机中首选的新生代收集器，其中有一个与性能无关但很重要的原因是，除了Serial收集器外，目前只有它能与CMS收集器配合工作。
      ParNew收集器也是使用-XX:+UseConcMarkSweepGC选项后的默认新生代收集器，也可以使用-XX:+UseParNewGC.选项来强制指定它。
      ParNew收集器在单CPU的环境中绝对不会有比Serial收集器更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个CPU的环境中都不能百分之百地保证能超越Serial收集器。当然，随着可以使用的CPU的数量的增加，它对于GC时系统资源的利用还是很有好处的。它默认开启的收集线程数与CPU的数量相同，在CPU非常多(譬如32个，现在CPU动辄就4核加超线程，服务器超过32个逻辑CPU的情况越来越多了)的环境下，可以使用-XX:ParallelGCThreads 参数来限制垃圾收集的线程数。
    3.ParallelScavenge收集器
        也是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器.....
        CMS等收集器的关注点尽可能地缩短垃圾收集时用户线程的停顿时间，而ParallelScavenge收集器的目标则是达到-一个可控制的吞吐量(Throughput)。
        所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)，虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户的体验;而高吞吐量则可以最高效率地利用CPU时间，尽快地完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。
        Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的-XX:MaxGCPauseMillis参数及直接设置吞吐量大小的-XX:GCTimeRatio参数。
    4.Serial Old收集器
      Serial Old是Serial 收集器的老年代版本，它同样是一个单线程收集器，使用“标记一整理”算法。这个收集器的主要意义也是被Client模式下的虚拟机使用。如果在Server模式下，它主要还有两大用途:一个是在JDK 1.5及之前的版本中与ParallelScavenge收集器搭配使用，另外一个就是作为CMS收集器的后备预案，在并发收集发生ConcurrentModeFailure的时候使用。
    5.Parallel Old收集器
      Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法.
      “吞吐量优先”收集器终于有了比较名副其实的应用组合，在注重吞吐量及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。
    6.CMS (Concurrent Mark Sweep)收集器
      是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用都集中在互联网站或B/S系统的服务端上,这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。
      从名字(包含“Mark Sweep")上就可以看出CMS收集器是基于“标记一清除”算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为4个步骤，包括:
        1.初始标记(CMS initial mark)
        2.并发标记(CMS concurrent mark)
        3.重新标记(CMS remark)
        4.并发清除(CMS concurrent sweep)
      其中初始标记、重新标记这两个步骤仍然需要“StopTheWorld"。初始标记仅仅只是标记一下GCRoots能直接关联到的对象，速度很快，并发标记阶段就是进行GCRootsTracing的过程，而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那--部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。
    三个显著缺点:
        1.对CPU资源非常敏感; 默认启动的回收线程数量 = (cpu数量+3)/4 ,当cu不足4个时,会导致用户线程变慢;
        2.无法处理浮动垃圾(Floating Garbage)
        3.产生大量碎片空间(因为是基于标准-清除算法);为了解决这个问题，CMS收集器提供了一个-XX:+UseCMSCompactAtFullCollection开关参数，用于在“享受”完FullGC服务之后额外免费附送一个碎片整理过程，内存整理的过程是无法并发的。空间碎片问题没有了，但停顿时间不得不变长了。虚拟机设计者们还提供了另外一个参数-XX: CMSFullGCsBeforeCompaction,这个参数用于设置在执行多少次不压缩的Full GC后，跟着来一次带压缩的。
    7.G1
        1.一是G1收集器是基于“标记-整理”算法实现的收集器，也就是说它 不会产生空间碎片;
        2.它可以非常精确地控制停顿，既能让使用者明确指定在一一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java(RTSJ)的垃圾收集器的特征了。
        G1收集器可以实现在基本不牺牲吞吐量的前提下完成低停顿的内存回收，这是由于它能够极力地避免全区域的垃圾收集，之前的收集器进行收集的范围都是整个新生代或老年代，而G1将整个Java堆(包括新生代、老年代划分为多个大小固定的独立区域(Region)，并且跟踪这些区域里面的垃圾堆积程度，在后台维护一个优先列表，每次根据允许的收集时间，优先回收垃圾最多的区域(这就是Garbage First名称的来由)。区域划分及有优先级的区域回收，保证了G1收集器在有限的时间内可以获得最高的收集效率。

 垃圾收集的常用参数:
    参数                                      描述
    UseSerialGC             虚拟机运行在Client模式下的默认值，打开此开关后，使用Serial +SerialOld的收集器组合进行内存回收;
    UseParNewGC             打开此开关后，使用ParNew+SerialOld的收集器组合进行内存回收;
    UseConcMarkSweepGC      打开此开关后，使用ParNew + CMS + Serial Old的收集器组合进行内存回收;
                            SerialOld收集器将作为CMS收集器出现ConcurrentModeFailure失败后的后备收集器使用,
    UseParallelGC           虚拟机运行在Server模式下的默认值，打开此开关后，使用Parallel Scavenge + Serial Old (PS MarkSweep的收集器组合进行内存回收;
    UseParallelOldGC        打开此开关后，使用Parallel Scavenge + Parallel Old的收集器组合进行内存回收
    SurvivorRatio           新生代中Eden区域与Survivor区域的容量比值，默认为8，代表Eden : Survivor-8: 1;
    PretenureSizeThreshold  直接晋升到老年代的对象大小，设置这个参数后，大于这个参数的对象将直接在老年代分配;
    MaxTenuringThreshold    晋升到老年代的对象年龄。每个对象在坚持过.次MinorGC之后，年龄就加1,当超过这个参数值时就进入老年代(默认是15);
    UseAdaptiveSizePolicy   动态调整Java堆中各个区域的大小以及进入老年代的年龄;
    HandlePromotionFailure  是否允许分配担保失败，即老年代的剩余空间不足以应付新生代的整个Eden和Survivor区的所有对象都存活的极端情况;
    ParallelGCThreads       设置并行GC时进行内存回收的线程数;
    GCTimeRatio             GC时间占总时间的比率，默认值为99,即允许1%的GC时间。仅在使用Parallel Scavenge收集器时生效;
    MaxGCPauseMillis        设置GC的最大停顿时间。仅在使用ParallelScavenge收集器时生效
    CMSInitiatingOccupancyFraction 设置CMS收集器在老年代空间被使用多少后触发垃圾收集。默认值为68%，仅在使用CMS收集器时生效
    UseCMSCompactAtFullCollection   设置CMS收集器在完成垃圾收集后是否要进行一次内存碎片整理。仅在使用CMS收集器时生效
    CMSFullGCsBeforeCompaction      设置CMS收集器在进行若干次垃圾收集后再启动一次内存碎片整理。仅在使用CMS收集器时生效

 -XX:+PrintGCDetails:告诉虚拟机在发生垃圾收集行为时打印内存回收日志，并且在进程退出的时候输出当前内存各区域的分配情况。在实际应用中，内存回收日志-般是打印到文件后通过日志工具进行分析;
 -Xms20M : 最小堆大小20M;
 -Xmx20M : 最大堆大20M;
 -Xmn10M : 年轻代大小10m;
 -XX:SurvivorRatio=8
 新生代GC(Minor GC):指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。
 老年代GC(Major GC/ Full GC):指发生在老年代的GC，出现了Major GC,经常会伴随至少一次的Minor GC(但非绝对的，在ParallelScavenge收集器的收集策略里就有直接进行Major GC的策略选择过程)。MajorGC的速度一般会比Minor GC慢10倍以上。
 
   `大对象直接进入老年代`: 所谓大对象就是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串及数组(笔者例子中的byte[] 数组就是典型的大对象)。大对象对虚拟机的内存分配来说就是一个坏消息(比遇到一个大对象更加坏的消息就是遇到一群“朝生夕灭”的“短命大对象”，写程序的时候应当避免)，经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”它们。虚拟机提供了一一个-XX:PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代中分配。这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存拷贝(复习一下:新生代采用复制算法收集内存)。

   `长期存活的对象将进入老年代`: 虚拟机给每个对象定义了一个对象年龄(Age)计数器。如果对象在Eden出生并经过第次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将对象年龄设为1。对象在Survivor区中每熬过一次 Minor GC,年龄就增加1岁，当它的年龄 增加到一定程度(默认为15岁)时，就会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数-XX:Max TenuringThreshold来设置。

   `动态对象年龄判定`: 为了能更好地适应不同程序的内存状况，虚拟机并不总是要求对象的年龄必须达到MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进人老年代，无须等到MaxTenuringThreshold中要求的年龄。

   `空间分配担保`:在发生Minor GC时，虚拟机会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间大小，如果大于，则改为直接进行一次Full GC。如果小于，则查看HandlePromotionFailure设置是否允许担保失败;如果允许，那只会进行Minor GC;如果不允许，则也要改为进行一次Full GC。新生代使用复制收集算法，但为了内存利用率，只使用其中一个Survivor空间来作为轮换备份，因此当出现大量对象在MinorGC后仍然存活的情况时(最极端就是内存回收后新生代中所有对象都存活),就需要老年代进行分配担保，让Survivor无法容纳的对象直接进入老年代。老年代要进行这样的担保，前提是老年代本身还有容纳这些对象的剩余空间，一共有多少对象会活下来，在实际完成内存回收之前是无法明确知道的，所以只好取之前每~次回收晋升到老年代对象容量的平均大小值作为经验值，与老年代的剩余空间进行比较，决定是否进行FullGC来让老年代腾出更多空间。取平均值进行比较其实仍然是一一种动态概率的手段，也就是说如果某次MinorGC存活后的对象突增，远远高于平均值的话，依然会导致担保失败(HandlePromotion Failure。如果出现了HandlePromotionFailure失败，那就只好在失败后重新发起一次FullGC。虽然担保失败时绕的圈子是最大的，但大部分情况下都还是会将HandlePromotionFailure开关打开，避免Full GC过于频繁;
  
 Sun JDK监控和故障处理工具:
     名称		主要作用
     jps		JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程
     jstat		JVM Statistics Monitoring Tool,用于收集HotSpot虚拟机各方面的运行数据
     jinfo		Configuration Info for Java,显示虚拟机配置信息
     jmap		MemoryMapforJava,生成虚拟机的内存转储快照(heapdump文件)
     jhat		JVM Heap Dump Browser, 用于分析heapdump文件，它会建立一个HTTP/HTML服务器，让用户可以在浏览器上查看分析结果
     jstack		Stack Trace for Java,显示虚拟机的线程快照

 jstat :虚拟机统计信息监视工具
    jstat (JVM Statistics Monitoring Tool)是用于监视虚拟机各种运行状态信息的命令行工具。它可以显示本地或远程虚拟机进程中的类装载、内存、垃圾收集、JIT 编译等运行数据，在没有GUI图形界面，只提供了纯文本控制台环境的服务器上，它将是运行期定位虚拟机性能问题的首选工具。
    jstat命令格式为: jstat [ option vmid [interval [s |ms] [count]] ]
    参数interval和count代表查询间隔和次数，如果省略这两个参数，说明只查询一次。假设需要每250毫秒查询次进程2764垃圾收集的状况，-共查询20次，那命令应当是:
        jstat -gc 2764 250 20 ; 更多参数请看 jstat工具主要选项.png
 jmap : Java内存映像工具
    jmap(MemoryMapforJava)命令用于生成堆转储快照(一般称为heapdump或dump文件)。jmap的作用并不仅仅是为了获取dump文件，它还可以查询finalize执行队列，Java堆和永久代的详细信息，如空间使用率、当前用的是哪种收集器等。
    jmap命令格式:   jmap [ option ] vmid
    参数: jmap工具主要选项.png
    
 JDK的可视化工具: JConsole和VisualVM

 在32位Windows平台中每个进程只能使用2GB的内存，考虑到堆以外的内存开销，堆一般最多只能开到1.5GB。在某些Linux, Unix系统(如Solaris) 中，可以提升到3GB乃至接近4GB的内存，但32位中仍然受最高4GB (2^32) 内存的限制。

 除了Java堆和永久代之外，下面这些区域还会占用较多的内存，这里所有的内存总和会受到操作系统进程最大内存的限制:
    1.Direct Memory :可通过-XX:MaxDirectMemorySize调整大小，内存不足时抛出OutOfMemoryError 或OutOfMemoryError: Direct buffer memory。
    2.线程堆栈:可通过-Xss调整大小，内存不足时抛出StackOverflowError (纵向无法分配，即无法分配新的栈帧)或OutOfMemoryError: unable to create new native thread(横向无法分配，即无法建立新的线程)。
    3.Socket缓存区:每个Socket连接都Receive和Send两个缓存区，分别占大约37KB和25KB的内存，连接多的话这块内存占用也比较可观。如果无法分配，则可能会抛出IOException: Too many open files 异常。
    4.JNI代码:如果代码中使用JNI调用本地库，那本地库使用的内存也不在堆中。
    5.虚拟机和GC:虚拟机和GC的代码执行也要消耗一定的内存。

 通过Java的Runtime.getRuntime().exec()方法可以用来调用shell脚本。但是它在Java虚拟机中非常消耗资源，即使外部命令本身能很快执行完毕，频繁调用时创建进程的开销也非常可观。Java虚拟机执行这个命令的过程是:首先克隆一个和当前虚拟机拥有一样环境变量的进程，再用这个新的进程去执行外部命令，最后再退出这个进程。如果频繁执行这个操作，系统的消耗会很大，不仅是CPU,内存的负担也很重。
 
参数-Xverify:none : 禁止字节码验证过程,意思为不需要在加载的时候再进行字节码验证
查看类加载所消耗时间 : jstat -class pid

   编译时间 : 是指虚拟机的JIT编译器(Just In Time Compiler)编译热点代码(Hot Spot Code)的耗时。我们知道Java语言为了实现跨平台的特性，Java代码编译出来后形成的Class文件中储存的是字节码(ByteCode)，虚拟机通过解释方式执行字节码命令，比起C/C++编译成本地二进制代码来说，速度要慢不少。为了解决程序解释执行的速度问题，JDK1.2以后，虚拟机内置了两个运行时编译器”，如果一-段Java方法被调用的次数到达一定程度，就会被判定为热代码，从而交给JIT编译器即时编译为本地代码，以提高运行速度(这就是HotSpot虚拟机名字的由来)。甚至有可能在运行期动态编译比C/C++的编译器静态编译出来的代码更优秀，因为运行期可以收集很多编译器无法知道的信息，甚至可以采用一些很激进的优化手段，在优化条件不成立的时候再逆优化退回来。所以Java程序只要代码没有问题(主要是泄漏问题，如内存泄漏、连接泄漏)，随着代码被编译得越来越彻底，运行速度应当是越来越快。Java运行期编译最大的缺点就是编译需要消耗程序正常的运行时间，也就是上面所说的“编译时间”。

参数 -XX:+DisableExplicitGC : 屏蔽掉System.gc()。
ParNew收集器是使用CMS收集器后的默认新生代收集器;
CMS默认老年代使用了68%就进行收集，使用-XX:CMSInitiatingOccupancyFraction=85将GC临界值提升到85%;

   实现语言无关性的基础是虚拟机和字节码存储格式，使用Java编译器可以把Java代码编译为存储字节码的Class文件，使用JRuby等其他语言的编译器样可以把程序代码编译成Class文件，虚拟机并不关心Class的来源是什么语言，只要它符合Class文件应有的结构就可以在Java虚拟机中运行;

Class文件格式.png

魔数与Class文件的版本
    每个Class文件的头4个字节称为魔数(MagicNumber),它的唯一作用是用于确定这个文件是否为一个能被虚拟机接受的Class文件。很多文件存储标准中都使用魔数来进行身份识别，譬如图片格式，如gif 或jpeg等在文件头中都存有魔数。使用魔数而不是扩展名来进行识别主要是基于安全考虑，因为文件扩展名可以很随意地被改动。文件格式的制定者可以自由地选择魔数值，只要这个魔数值还没有被广泛采用过而且不会引起混淆即可。Class文件的魔数值为: 0xCAFEBABE;
    紧接着魔数的4个字节存储的是Class文件的版本号:第5和第6个字节是次版本号(Minor Version),第7个和第8个字节是主版本号(Major Version)。Java 的版本号是从45开始的，JDK1.1能支持版本号为45.0 ~ 45.65535的Class,无法执行版本号为46.0以上的Class,而JDK 1.2则能支持45.0~46.65535的Class文件。JDK版本为1.7为51,jdk1.8为52;

制定Class文件格式规范时，将第0项常量空出来是有特殊考虑的，这样做是为了满足后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的意思，这种情况就可以把索引值置为0来表示。Class文件结构中只有常量池的容量计数是从1开始的，对于其他集合类型，包括接口索引集合、字段表集合、方法表集合等的容量计数都与一般习惯相同，是从0开始的。

由于Class文件中方法、字段等都需要引用CONSTANT _Utf8_ info型常量来描述名称，所以CONSTANTUtf8_info型常量的最大长度也就是`Java中方法和字段名的最大长度`。而这里的最大长度就是length的最大值，即u2类型能表达的最大值`65535`。所以Java程序中如果定义了超过64KB英文字符的变量或方法名，将会无法编译。

常量池11中数据类型的结构总表.png
访问标志.png

数组类型，每一维度将使用一个前置的“[”字符来描述，如一个定义为“java.lang.String[][]"类型的二维数组，将被记录为:“[[Ljava/lang/String;",
一个整型数组“int[]”将被记录为“[I”。

在Java语言中字段是无法重载的，两个字段的数据类型、修饰符不管是否相同，都必须使用不一一样的名称，但是对于字节码来讲，如果两个字段的描述符不一致，那字段重名就是合法的。

父类方法在子类中没有被重写(Override),方法表集合中就不会出现来自父类的方法信息。但同样的，有可能会出现由编译器自动添加的方法，最典型的便是类构造器“<clinit>"方法和实例构造器“<init>"方法”。

在Java语言中，要重载(Overload)一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的`特征签名`，特征签名就是一个方法中各个参数在常量池中的字段符号引用的集合，也就是因为返回值不会包含在特征签名之中，因此Java语言里面是无法仅仅依靠返回值的不同来对一个已有方法进行重载的。但是在Class文件格式之中，特征签名的范围更大一些，只要描述符不是完全一致的两个方法也可以共存。也就是说，如果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法共存于同一个Class文件中的。

Java代码的方法特征签名只包括了方法名称、参数顺序及参数类型，而字节码的特征签名还包括方法返回值及受查异常表。
方法属性表.png

Slot是虚拟机为局部变量分配内存所使用的最小单位。对于byte、char、float、int、short、boolean、 reference 和returnAddress等长度不超过32位的数据类型，每个局部变量占用1个Slot,而double和long这两种64位的数据类型则需要2个Slot来存放。

局部变量表(max_locals表示局部变量表的长度) : 并不是在方法中用到了多少个局部变量，就把这些局部变量所占的Slot之和作为max_locals的值，原因是局部变量表中的Slot可以重用，当代码执行超出一个局部变量的作用域时，这个局部变量所占的Slot就可以被其他局部变量所使用，编译器会根据变量的作用域来分类Slot并分配给各个变量使用，然后计算出max locals的大小。

code_ length(方法体的长度) : 虽然它是一个u4类型的长度值，理论上最大值可以达到232-1,但是虚拟机规范中限制了一个方法不允许超过65535条字节码指令，如果超过这个限制，Javac编译器就会拒绝编译.一般来讲，只要我们写Java代码时不是刻意去编写超长的方法，就不会超过这个最大值的限制。但是，在编译复杂的JSP文件时，可能会因为这个原因而导致编译失败。

字节码指令具体描述请看oracle网站 : https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.dup

类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括了:加载(Loading)、验证(Verification)、 准备( Preparation)、解析(Resolution)、初始化(Initialization)、 使用(Using)和卸载(Unloading)七个阶段。其中验证、准备和解析三个部分统称为连接(Linking)

加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定:它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定(也称为动态绑定或晚期绑定).

对于初始化阶段，虚拟机规范则是严格规定了有且只有四种情况必须立即对类进行“初始化”:
    1)遇到new、getstatic、 putstatic 或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是:使用new关键字实例化对象的时候、读取或设置一个类的静态字段(被final修饰、已在编译期把结果放人常量池的静态字段除外)的时候，以及调用一个类的静态方法的时候。
    2)使用java.lang.reflect包的方法对类进行发射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。
    3)当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
    4)当虚拟机启动时，用户需要指定一个要执行的主类(包含main()方法的那个类)，虚拟机会先初始化这个主类(启动类)。
    对于这四种会触发类进行初始化的场景，虚拟机规范中使用了一个很强烈的限定语:“有且只有”，这四种场景中的行为称为对一个类进行`主动引用`。除此之外所有引用类的方式，都不会触发初始化，称为`被动引用`。
    
对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。至于是否要触发子类的加载和验证，在虚拟机规范中并未明确规定，这点取决于虚拟机的具体实现。对于Sun HotSpot虚拟机来说，可通过-XX:+TraceClassLoading参数看到此操作会导致子类的加载。

引用非本类中的常量HELLOWORLD,在编译阶段会将此常量的值"hello world"存储到了本类的常量池中，对其他类的常量的引用实际都被转化为本类对自身常量池的引用了。也就是说实际上
本类的Class文件之中并没有其他类的符号引用人口，这两个类在编译成Class之后就不存在任何联系了。

当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候(如引用接口中定义的常量)才会初始化。

在**加载**阶段，虚拟机需要完成以下三件事情:
    1)通过一个类的全限定名来获取定义此类的二进制字节流。
    2)将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
    3)在Java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问人口。

**验证**是连接阶段的第-一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

**准备**阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配。

**解析**阶段是虚拟机将常量池内的符号引用替换为直接引用的过程;在Class文件中它以CONSTANT_Class_ info、CONSTANT Fieldref info、CONSTANT Methodref info等类型的常量出现，
    符号引用(Symbolic References):符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不定已经加载到内存中。
    直接引用(Direct References):直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在内存中存在。
    虚拟机规范之中并未规定解析阶段发生的具体时间，只要求了在执行anewarray、checkcast、getfield、 getstatic、 instanceof、 invokeinterface、 invokespecial、 invokestatic、invokevirtual、multianewarray、 new、putfield 和putstatic这13个用于操作符号引用的字节码指令之前，先对它们所使用的符号引用进行解析。所以虚拟机实现会根据需要来判断，到底是在类被加载器加载时就对常量池中的符号引用进行解析，还是等到一个符号引用将要被使用前才去解析它。

解析动作主要针对类或接口、字段、类方法、接口方法四类符号引用进行，分别对应于常量池的CONSTANT Class_ info、 CONSTANT Fieldref_ info、CONSTANT Methodref_info及CONSTANT InterfaceMethodref_ info 四种常量类型”。
    `1.类或接口的解析`
      假设当前代码所处的类为D,如果要把一个从未解析过的符号引用N解析为一个类或接口C的直接引用，那虚拟机完成整个解析的过程需要包括以下3个步骤:
      1.1)如果C不是一个数组类型，那虚拟机将会把代表N的全限定名传递给D的类加载器去加载这个类C。在加载过程中，由于无数据验证、字节码验证的需要，又将可能触发其他相关类的加载动作，例如加载这个类的父类或实现的接口。一旦这个加载过程出现了任何异常，解析过程就将宣告失败。
      1.2)如果C是一个数组类型，并且数组的元素类型为对象，也就是N的描述符会是类似“[Ljava.lang.Integer”的形式，那将会按照第1点的规则加载数组元素类型。如果N的描述符如前面所假设的形式，需要加载的元素类型就是“java.lang.Integer", 接着由虚拟机生成一个代表此数组维度和元素的数组对象。
      1.3)如果上面的步骤没有出现任何异常，那么C在虚拟机中实际上已经成为一个有效的类或接口了，但在解析完成之前还要进行符号引用验证，确认C是否具备对D的访问权限。如果发现不具备访问权限，将抛出java.langlllegalAccessError异常。
    `2.字段解析`
      要解析一个未被解析过的字段符号引用，首先将会对字段表内class index”项中索引的CONSTANT Class_ info 符号引用进行解析，也就是字段所属的类或接口的符号引用。如果在解析这个类或接口符号引用的过程中出现了任何异常，都会导致字段符号引用解析的失败。如果解析成功完成，那将这个字段所属的类或接口用C表示，虚拟机规范要求按照如下步骤对C进行后续字段的搜索:
      2.1)如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。
      2.2)否则，如果在C中实现了接口，将会按照继承关系从上往下递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。
      2.3)否则，如果C不是java.lang.Object的话，将会按照继承关系从上往下递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。
      2.4)否则，查找失败，抛出java.lang.NoSuchFieldError异常。如果查找过程成功返回了引用，将会对这个字段进行权限验证，如果发现不具备对
字段的访问权限，将抛出java.langlllegalAccessError异常。
    在实际应用中，虚拟机的编译器实现可能会比上述规范要求得更加严格一些，如果有一个同名字段同时出现在C的接口和父类中，或者同时在自己或父类的多个接口中出现，那编译器将可能拒绝编译。
    `3.类方法解析`
      类方法解析的第一个步骤与字段解析一样，也是需要先解析出类方法表的class_index项中索引的方法所属的类或接口的符号引用，如果解析成功，依然用C表示这个类，接下来虚拟机将会按照如下步骤进行后续的类方法搜索:
      3.1)类方法和接口方法符号引用的常量类型定义是分开的，如果在类方法表中发现class index中索引的C是个接口，那就直接抛出java.lang. IncompatibleClassChangeError
异常。
      3.2)如果通过了第(1)步，在类C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。
      3.3)否则，在类C的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。
      3.4)否则，在类C实现的接口列表及它们的父接口之中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果存在匹配的方法，说明类C是一个抽象类，这时候查找结束，抛出java.lang. AbstractMethodError异常。
      3.5)否则，宣告方法查找失败，抛出java.lang. NoSuchMethodError。
      最后，如果查找过程成功返回了直接引用，将会对这个方法进行权限验证;如果发现不具备对此方法的访问权限，将抛出java.lang.IllegalAccessError异常。
   ` 4.接口方法解析`
      接口方法也是需要先解析出接口方法表的classindex"项中索引的方法所属的类或接口的符号引用，如果解析成功，依然用C表示这个接口，接下来虚拟机将会按照如下
步骤进行后续的接口方法搜索:
      4.1)与类方法解析相反，如果在接口方法表中发现class _index 中的索引C是个类而不是接口，那就直接抛出java.lang. IncompatibleClassChangeError 异常。
      4.2)否则，在接口C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。
      4.3)否则，在接口C的父接口中递归查找，直到javalang.Object类(查找范围会包括Object类)为止，看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。
      4.4)否则，宣告方法查找失败，抛出java.lang. NoSuchMethodError异常。
      由于接口中的所有方法都默认是public的，所以不存在访问权限的问题，因此接口方法的符号解析应当不会抛出java.lan.llegalAccessError异常。

类**初始化**阶段是类加载过程的最后一步;到了初始化阶段，才真正开始执行类中定义的Java程序代码(或者说是字节码)。在准备阶段，变量已经赋过-次 系统要求的初始值， 而在初始化阶段，则是根据程序员通过程序制定的主观计划去初始化类变量和其他资源;

**clinit说明:**
   1. <clinit>(方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块(static{}块)中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块中可以赋值，但是不能访问。
   2. <clinit>(方法与类的构造函数(或者说实例构造器<init>(方法)不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的<clinit>0方法执行之前，父类 的<clinit>()方法已经执行完毕。因此在虚拟机中第一个 被执行的<clinit>( 方法的类肯定是java.lang.Object.
   3. 由于父类的<clinit>方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作;
   4. <clinit>(方法对于类或接口来说并不是必须的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<clinit>O 方法。
   5. 接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成<clinit>方法。但接口与类不同的是，执行接口的<clinit>()方法不需要先执行父接口的<clinit>O方法。只有当父接口中定义的变量被使用时父接口才会被初始化。另外，接口的实现类在初始化时也一样不会执行接口的<clinit>()方法。
   6. 虚拟机会保证一个类的<clinit>方法在多线程环境中被正确地加锁和同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>方法，其他线程都需要阻塞等待，直到活动线程执行<clinit>方法完毕。如果在一个类的<clinit>方法中有耗时很长的操作，那就可能造成多个进程阻塞，在实际应用中这种阻塞往往是很隐蔽的。

比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提之下才有意义，否则，即使这两个类是来源于同一个Class文件，只要加载它们的类加载器不同，那这两个类就必定不相等。

从Java虚拟机的角度讲，只存在两种不同的类加载器:
    一种是启动类加载器(Bootstrap ClassLoader),这个类加载器使用C++语言实现，是虚拟机自身的部分;
    另外一种就是所有其他的类加载器，这些类加载器都由Java语言实现，独立于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader。
从Java开发人员的角度来看，类加载器就还可以划分得更细致一些，绝大部分Java程序都会使用到以下三种系统提供的类加载器:
    1.启动类加载器( Bootstrap ClassLoader):前面已经介绍过，这个类加载器负责将存放在<JAVA_ HOME>\lib 目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的(仅按照文件名识别，如rtjar,名字不符合的类库即使放在lib目录中也不会被加载)类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用。
    2.扩展类加载器(Extension ClassLoader): 这个加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载<JAVA_ HOME>\lib\ext 目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。
    3.应用程序类加载器(Application ClassLoader): 这个类加载器由sun.misc.Launcher$AppClassLoader来实现。由于这个类加载器是ClassLoader中的getSystemClassLoader(方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径(ClassPath) 上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。

双亲委派模型的工作过程是:如果-个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求(它的搜索范围中没有找到所需的类)时，子加载器才会尝试自己去加载。


运行时栈帧结构
    栈帧(StackFrame)是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈(VirtualMachineStack)的栈元素。栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。每一个方法从调用开始到执行完成的过程，就对应着-一个栈帧在虚拟机栈里面从入栈到出栈的过程。
    每一个栈帧都包括了局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息。在编译程序代码的时候，栈帧中需要多大的局部变量表、多深的操作数栈都已经完全确定了，并且写人到方法表的Code属性之中”，因此一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。
    一个线程中的方法调用链可能会很长，很多方法都同时处于执行状态。对于执行引擎来讲，活动线程中，只有栈顶的栈帧是有效的，称为当前栈帧(Current Stack Frame),这个栈帧所关联的方法称为当前方法(Current Method)。执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作，栈帧的概念结构如 栈帧概念结构.png
    
   局部变量表: 
      局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。在Java程序被编译为Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需要分配的最大局部变量表的容量。
      局部变量表的容量以变量槽( Variable Slot,下称 Slot)为最小单位，虚拟机规范中并没有明确指明一个Slot应占用的内存空间大小，只是很有“导向性”地说明每个Slot都应该能存放一个boolean、byte、 char、 short、 int、 float、 reference 或returnAddress类型的数据，这种描述与明确指出“每个Slot占用32位长度的内存空间”有一些差别，它允许Slot的长度随着处理器、操作系统或虚拟机的不同而发生变化。不过无论如何，即使在64位虚拟机中使用了64位长度的内存空间来实现一个Slot,虚拟机仍要使用对齐和补白的手段让Slot在外观上看起来与32位虚拟机中的一致。
      returnAddress是为字节码指令jsr、jsr_w和ret服务的，它指向了一条字节码指令的地址。
      对于64位的数据类型，虚拟机会以高位在前的方式为其分配两个连续的Slot空间。Java语言中明确规定的64位的数据类型只有long和double两种(reference类型则可能是32位也可能是64位)。
      由于局部变量表建立在线程的堆栈上，是线程私有的数据，无论读写两个连续的Slot是否是原子操作，都不会引起数据安全问题”。
      虚拟机通过索引定位的方式使用局部变量表，索引值的范围是从0开始到局部变量表最大的Slot数量。如果是32位数据类型的变量，索引n就代表了使用第n个Slot,如果是64位数据类型的变量，则说明要使用第n和第n+1两个Slot。
      局部变量表中的Slot是可重用的，方法体中定义的变量，其作用域并不一定会覆盖整个方法体，如果当前字节码PC计数器的值已经超出了某个变量的作用域，那么这个变量对应的Slot就可以交给其他变量使用。这样的设计不仅仅是为了节省栈空间，在某些情况下Slot的复用会直接影响到系统的垃圾收集行为;
      如果一个局部变量定义了但没有赋初始值是不能使用的。所以不要认为Java中任何情况下都存在诸如整型变量默认为0、布尔型变量默认为false之类的默认值。

   操作数栈:
      操作数栈也常被称为操作栈，它是一个后人先出(Last In First Out, LIFO)栈。同局部变量表-样，操作数栈的最大深度也在编译的时候被写人到Code属性的max_ stacks 数据项之中。操作数栈的每一个元素可以是任意的Java数据类型，包括long和double。32位数据类型所占的栈容量为1,64位数据类型所占的栈容量为2。
      在方法执行的任何时候，操作数栈的深度都不会超过在max_stacks数据项中设定的最大值。
      当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令向操作数栈中写人和提取内容，也就是人栈出栈操作。
      在概念模型中，两个栈帧作为虚拟机栈的元素，相互之间是完全独立的。但是大多数虚拟机的实现里都会做一些优化处理，令两个栈帧出现部分重叠。让下面栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起，这样在进行方法调用时就可以共用一部分数据，而无须进行额外的参数复制传递了;

   动态连接
       每个栈帧都包含一个指向运行时常量池”中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用部分 会在类加载阶段或第一次使用的时候转化为直接引用，这种转化称为静态解析。另外-部分将在每一次的运行期间转化为直接引用，这部分称为动态连接。
       
   方法返回地址
       当一个方法被执行后，有两种方式退出这个方法。第一种方式是执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者(调用当前方法的方法称为调用者)，是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为正常完成出口(Normal Method InvocationCompletion)。
       另外一种退出方式是，在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，无论是Java虚拟机内部产生的异常，还是代码中使用athrow字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方法的方式称为异常完成出口( Abrupt Method Invocation Completion);一个方法使用异常完成出口的方式退出，是不会给它的上层调用者产生任何返回值的。
       无论采用何种退出方式，在方法退出之后，都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。-般来说，方法正常退出时，调用者的PC计数器的值就可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是要通过异常处理器表来确定的，栈帧中般不会保存这部分信息。方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有:恢复上层方法的局部变量表和操作数栈，把返回值(如果有的话)压人调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的-条指令等。
       
方法调用
   方法调用并不等同于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本(即调用哪-一个方法)，暂时还不涉及方法内部的具体运行过程。在程序运行时，进行方法调用是最普遍、最频繁的操作，但前面已经讲过，Class 文件的编译过程中不包含传统编译中的连接步骤，一切方法调用在Class文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局中的人口地址(相当于之前所说的直接引用)。这个特性给Java带来了更强大的动态扩展能力，但也使得Java方法的调用过程变得相对复杂起来，需要在类加载期间甚至到运行期间才能确定目标方法的直接引用。
   
   解析
      所有方法调用中的目标方法在Class文件里面都是一个常量池中的符号引用，在类加载的解析阶段，会将其中的部分 符号引用转化为直接引用，这种解析能成立的前提是:方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。换句话说，调用目标在程序代码写好、编译器进行编译时就必须确定下来。这类方法的调用称为解析(Resolution)。
      在Java语言中，符合“编译期可知，运行期不可变”这个要求的方法主要有静态方法和私有方法两大类，前者与类型直接关联，后者在外部不可被访问，这两种方法都不
可能通过继承或别的方式重写出其他版本，因此它们都适合在类加载阶段进行解析。
      与之相对应，在Java虚拟机里面提供了四条方法调用字节码指令，分别是:
        1. invokestatic :调用静态方法。
        2. invokespecial:调用实例构造器<init> 方法、私有方法和父类方法。
        3. invokevirtual :调用所有的虚方法。
        4. invokeinterface :调用接口方法，会在运行时再确定一个实现此接口的对象。
        只要能被invokestatic和invokespecial指令调用的方法，都可以在解析阶段确定唯-的调用版本，符合这个条件的有静态方法、私有方法、实例构造器和父类方法四类，它们在类加载的时候就会把符号引用解析为该方法的直接引用。这些方法可以称为`非虚方法`，与之相反，其他方法就称为`虚方法`(除去final方法)。
      在Java语言规范中明确说明了final方法是一种非虚方法。
      解析调用一定是个静态的过程，在编译期间就完全确定，在类装载的解析阶段就会把涉及的符号引用全部转变为可确定的直接引用，不会延迟到运行期再去完成。而分派(Dispatch)调用则可能是静态的也可能是动态的，根据分派依据的宗量数可分为单分派和多分派。这两类分派方式两两组合就构成了静态单分派、静态多分派、动态单分派、动态多分派四种分派情况;
      变长参数的重载优先级是最低的;
      
   invokevirtual指令的运行时解析过程大致分为以下步骤:
      1)找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C。
      2)如果在类型C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束;不通过则返回java.lang. IllegalAccessError异常。
      3)否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。
      4)如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。由于invokevirtual指令执行的第一步就是在运行期确定接收者的实际类型，所以两次调用中的invokevirtual指令把常量池中的类方法符号引用解析到了不同的直接引用上，这个过程就是Java语言中方法重写的本质。我们把这种在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。
      方法表一般在类加载的连接阶段进行初始化，准备了类的变量初始值后，虚拟机会把该类的方法表也初始化完毕。

基于栈的指令集与基于寄存器的指令集
    Java编译器输出的指令流，基本上是一种基于栈的指令集架构(InstructionSet Architecture, ISA), 指令流里面的指令大部分都是零地址指令，它们依赖操作数栈进行工作。与之相对的另外一套常用的指令集架构是基于寄存器的指令集，最典型的就是x86的二地址指令集，更通俗一一些，就是现在我们主流PC中直接支持的指令集架构，这些指令依赖寄存器进行工作.
    基于栈:    同样操作指定更多 ; 移植性好 ; 速度慢
    基于寄存器: 同样操作指令更少 ; 依赖硬件 ; 速度快

跨越JDK版本之间的沟壑，把JDK1.5中编写的代码放到JDK1.4或1.3的环境中去部署和使用。为了解决这个问题，一种名为“Java逆向移植”的工具(Java Backporting Tools )应运而生，Retrotranslator是这类工具中最出色的一个。

自动装箱、拆箱在编译之后被转化成了对应的包装和还原方法;

字节码生成是Javac编译过程的最后一个阶段，在Javac源码里面由com.sun.tools.javac.jvm.Gen类来完成。字节码生成阶段不仅仅是把前面各个步骤所生成的信息(语法树、符号表)转化成字节码写到磁盘中，编译器还进行了少量的代码添加和转换工作。实例构造器<init>方法和类构造器<clinit>方法就是在这个阶段被添加到语法树之中的;

Java语言当然也可以进行条件编译，方法就是使用条件为常量的if语句。如下所示:
    if (true) {
        System. out . println("block 1") ;
    } else {
        System. out . println("block 2") ;
    }
    此代码编译后Class文件的反编译结果:
    System. out. println ("block 1") ;
    
在部分的商用虚拟机(SunHotSpot、IBMJ9)中，Java程序最初是通过解释器(Interpreter)进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁，就会把这些代码认定为“热点代码”(Hot Spot Code),为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为即时编译器(JustInTimeCompiler,下文中简称JIT编译器)。

   HotSpot虚拟机中内置了两个即时编译器，称为Client Compiler和Server Compiler,或者简称为C1编译器和C2编译器(也叫Opto编译器)。目前主流的HotSpot虚拟机中(Sun系列JDK1.6及之前版本的虚拟机)，默认是采用解释器与其中一个编译器直接配合的方式工作，程序使用哪个编译器，取决于虚拟机运行的模式，HotSpot 虚拟机会根据自身版本与宿主机器的硬件性能自动选择运行模式，用户也可以使用-client或-server参数去强制指定虚拟机运行在Client模式还是Server模式。

   解释器与编译器搭配使用的方式在虚拟机中被称为“混合模式”(MixedMode),用户可以使用参数-Xint强制虚拟机运行于“解释模式”(Interpreted Mode)，这时候编译器完全不介入工作，全部代码都使用解释方式执行。另外，也可以使用参数-Xcomp强制虚拟机运行于“编译模式”(Compiled Mode),这时候将优先采用编译方式执行程序，但是解释器仍然要在编译无法进行的情况下介入执行过程，可以通过虚拟机的-version命令的输出结果显示出这三种模式;
   java -version           ->   MixedMode
   java -Xint -version     ->   Interpreted Mode
   java -Xcomp -version    ->   Compiled Mode
   
   被即时编译器编译的“热点代码”有两类，即:
     1.被多次调用的方法。  经常调用的方法 , 编译器会以整个方法作为编译对象;
     2.被多次执行的循环体。方法体内部存在循环次数较多的循环体,被重复调用的循环体代码;  编译器同样会以整个方法作为编译对象,而不是循环体;
     这种编译方式因为编译发生在方法执行过程之中，因此被很形象地称为**栈上替换**(On Stack Replacement, OSR)。

     
   要知道一段代码是不是热点代码，是不是需要触发即时编译，这个行为称为**热点探测**(Hot Spot Detection),其实进行热点探测并不一定要知道方法具体被调用了多少次，目前主要的热点探测判定方式有两种，分别是:
     1.基于采样的热点探测(SampleBasedHotSpotDetection):采用这种方法的虚拟机会周期性地检查各个线程的栈顶，如果发现某个(或某些)方法经常出现在栈顶，那这个方法就是“热点方法”。基于采样的热点探测的好处是实现简单高效，还可以很容易地获取方法调用关系(将调用堆栈展开即可)，缺点是很难精确地确认一个方法的热度，容易因为受到线程阻塞或别的外界因素的影响而扰乱热点探测。
     2.基于计数器的热点探测(Counter Based Hot Spot Detection) :采用这种方法的虚拟机会为每个方法(甚至是代码块)建立计数器，统计方法的执行次数，如果执行次数超过一定的阈值就认为它是“热点方法”。这种统计方法实现起来麻烦一些，需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系。但是它的统计结果相对来说更加精确严谨。

   在HotSpot虚拟机中使用的是第二种一基 于计数器的热点探测方法，因此它为每个方法准备了两个计数器:方法调用计数器( Invocation Counter) 和回边计数器( BackEdge Counter)。
    方法调用计数器触发即时编译.png
    **方法调用计数器**:
       用于统计方法被调用的次数，它的默认阈值在Client模式下是1500次，在Server模式下是10000次，这个阈值可以通过虚拟机参数-XX:CompileThreshold来人工设定。当一个方法被调用时，会先检查该方法是否存在被JIT编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将此方法的调用计数器值加1,然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阈值。如果已超过阈值的话，将会向即时编译器提交一个该方法的代码编译请求。
       在默认设置下，执行引擎并不会同步等待编译请求完成，而是继续进入解释器按照解释方式执行字节码，直到提交的请求被编译器编译完成。当编译工作完成之后，这个方法的调用人口地址就会被系统自动改写成新的地址，下一次调用该方法时就会使用已编译的版本;
       在默认设置下，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间之内方法被调用的次数。当超过定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器的**热度衰减**(CounterDecay),而这段时间就称为此方法统计的**半衰周期**(Counter Half Life Time),进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数-XX:-UseCounterDecay来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码。另外可以使用-XX:CounterHalfLifeTime参数设置半衰周期的时间，单位是秒。
    **回边计数器**:
        它用于统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令就称为“回边(Back Edge)，显然建立回边计数器统计的目的就是为了触发OSR编译。
        当解释器遇到一条回边指令时，会先查找将要执行的代码片段是否有已经编译好的版本，如果有的话，它将会优先执行已编译的代码，否则就把回边计数器的值加1,然后判断方法调用计数器的值与回边计数器的值两者之和是否超过回边计数器的阈值。当超过阈值的时候，将会提交一个OSR编译请求，并且把回边计数器的值降低一些，以便继续在解释器中执行循环，等待编译器输出编译结果;
        与方法计数器不同，回边计数器没有计数热度衰减的过程，因此这个计数器统计的就是该方法循环执行的绝对次数。当计数器溢出的时候，它还会把方法计数器的值也调整到溢出状态，这样下次再进人该方法的时候就会执行标准编译过程。
        流程图 : 回边计数器触发即时编译.png
        
  要知道某个方法是否被编译过，可以使用参数-XX:+PrintCompilation要求虚拟机在即时编译时将被编译成本地代码的方法名称打印出来，带有“%”的输出说明是由回边计数器触发的OSR编译)。参数-XX:+PrintInlining要求虚拟机输出方法内联信息;
  
  Java程序员都有一个共同的认知，以编译方式执行本地代码比解释方式更快，其中除去虚拟机解释执行字节码时额外消耗的时间以外，还有一个很重要的原因就是JDK设计团队几乎把对代码的所有优化措施都集中在了即时编译器之中，所以一般来说即时编译器产生的本地代码会比Javac产生的字节码更优秀;
  《编译原理》
  
  **逃逸分析**的基本行为就是分析对象动态作用域:当一个对象在方法里面被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他方法中，这种行为称为方法逃逸。甚至还有可能被外部线程访问到，譬如赋值给类变量或可以在其他线程中访问的实例变量，这种行为称为**线程逃逸**。
    如果能证明一个对象不会逃逸到方法或线程之外，也就是别的方法或线程无法通过任何途径访问到这个对象，则可能为这个变量进行一些高效的优化，如:
        1.**栈上分配**( Stack Allocations) : Java虚拟机中，在Java堆上分配创建对象的内存空间几乎是Java程序员都清楚的常识了，Java堆中的对象对于各个线程都是共享和可见的，只要持有这个对象的引用，就可以访问堆中存储的对象数据。虚拟机的垃圾收集系统可以回收掉堆中不再使用的对象，但回收动作无论是筛选可回收对象，还是回收和整理内存都需要耗费时间。如果确定-一个对象不会逃逸出方法之外，那让这个对象在栈上分配内存将会是一个很不错的主意，对象所占用的内存空间就可以随栈帧出栈而销毁。在一般应用中，不会逃逸的局部对象所占的比率很大，如果能使用栈上分配，那大量的对象就会随着方法的结束而自动销毁了，垃圾收集系统的压力将会小很多。
        2.**同步消除**( Synchronization Elimination) :线程同步本身就是一个相对耗时的过程，如果逃逸分析能够确定-个变量不会逃逸出线程，无法被其他线程访问，那这个变量的读写肯定就不会有竞争，对这个变量实施的同步措施也就可以消除掉。
        3.**标量替换**( Scalar Replacement) :标量(Scalar) 是指一一个数据已经无法再分解成更小的数据来表示了，Java虚拟机中的原始数据类型(int、long等数值类型及reference类型等)都不能再进步分解，它们就可以被称为标量。相对的，如果一个数据可以继续分解，那它就被称做聚合量(Aggregate), Java中的对象就是最典型的聚合量。如果把一个Java对象拆散，根据程序访问的情况，将其使用到的成员变量恢复原始类型来访问就叫做标量替换。如果逃逸分析证明-个对象不会被外部访问，并且这个对象可以被拆散的话，那程序真正执行的时候将可能不创建这个对象，而改为直接创建它的若千个被这个方法使用到的成员变量来代替。将对象拆分后，除了可以让对象的成员变量在栈上(栈上存储的数据，很大机会会被虚拟机分配至物理机器的高速寄存器中存储)分配和读写之外，还可以为后续进步的优化手 段创建条件。
        
   使用参数-XX:+DoEscapeAnalysi来手动开启逃逸分析，开启之后可以通过参数-XX:+PrintEscapeAnalysis来查看分析果。
   可以使用参数-XX:+EliminateAllocations来开启标量替换，使用参数+XX:+EliminateLocks来开启同步消除，使用参数-XX:+PrintEliminateAllocations来查看标量的替换情况。
  
   Java内存模型规定了所有的变量都存储在主内存(MainMemory)中(此处的主内存与介绍物理硬件时的主内存名字-样，两者也可以互相类比，但此处仅是虚拟机内存的一部分)。每条线程还有自己的工作内存( Working Memory,可与前面所讲的处理器高速缓存类比)，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作(读取、赋值等)都必须在工作内存中进行，而不能直接读写主内存中的变量”。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成;
   这里所讲的主内存、工作内存与本书第2章所讲的Java内存区域中的Java堆、栈、方法区等并不是同一个层次的内存划分。如果两者定要 勉强对应起来，那从变量、主内存、工作内存的定义来看，主内存主要对应于Java堆中对象的实例数据部分”，而工作内存则对应于虚拟机栈中的部分区域。从更低的层次来说，主内存就是硬件的内存，而为了获取更好的运行速度，虚拟机及硬件系统可能会让工作内存优先存储于寄存器和高速缓存中。
   除了实例数据，Java 堆还保存了对象的其他信息，对于HotSpot虚拟机来讲，有Mark Word (存储对象哈希码、GC标志、GC年龄、同步锁等信息)、Klass Point(指向存储类型元数据的指针)及一些用于字节对齐补白的填充数据(如果实例数据刚好满足8字节对齐的话，则可以不存在补白)。

 内存间交互操作
   关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，Java 内存模型中定义了以下八种操作来完成”:
      1.lock (锁定):作用于主内存的变量，它把一个变量标识为: .条线程独占的状态。
      2.unlock (解锁) :作用于主内存的变量，它把一个处于锁定状态的变量释放出来,释放后的变量才可以被其他线程锁定。
      3.read(读取):作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。
      4.load(载人):作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。
      5.use (使用):作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。
      6.assign(赋值):作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
      7.store (存储):作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。
      8.write (写人) :作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。
   如果要把一个变量从主内存复制到工作内存，那就要按顺序地执行read和load操作，如果要把变量从工作内存同步回主内存，就要按顺序地执行store和write操作。注意，Java内存模型只要求上述两个操作必须按顺序执行，而没有保证必须是连续执行。也就是说read与load之间、store 与write之间是可插入其他指令的，如对主内存中的变量a、b进行访问时，-种可能出现的顺序是read a、read b、load b、load a。除此之外，Java内存模型还规定了在执行上述八种基本操作时必须满足如下规则:
      1.不允许read和load、store 和write操作之-单独出现， 即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现。
      2.不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。
      3.不允许一一个线程无原因地(没有发生过任何assign操作)把数据从线程的工作内存同步回主内存中。
      4.一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化(load 或assign)的变量，换句话说就是对一一个变量实施use和store操作之前，必须先执行过了assign 和load操作。
      5.一个变量在同一个时刻只允许-一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。
      6.如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。
      7.如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作;也不允许去unlock-一个被其他线程锁定住的变量。
      8.对一个变量执行unlock操作之前，必须先把此变量同步回主内存中(执行store和write操作)。
      
 volatile关键字:
    当一个变量被定义成volatile之后，它将具备两种特性，第一是保证此变量对所有线程的可见性，这里的“可见性”是指当一条线程修改了这个变 量的值，新值对于其他线程来说是可以立即得知的。而普通变量不能做到这-点，变量值在线程间传递均需要通过主内存来完成，如:线程A修改-一个普通变量的值，然后向主内存进行回写，另外一条线程B在线程A回写完成了之后再从主内存进行读取操作，新变量的值才会对线程B可见。
    Java里面的运算并非原子操作，导致volatile变量的运算在并发下一样是不安全的，如下多线程调用increase():
    public static volatile int race = 0;
    public static void increase() {
        race++ ;
    }
    结果每次都是小于正确结果,问题就出现在自增运算“race++” 之中，我们用Javap反编译这段代码后会发现只有一行代码的increase()方法在Class文件中是由4条字节码指令
构成的(return 指令不是由race++产生的，这条指令可以不算)，从字节码层面上很容易就分析出并发失败的原因了:当getstatic指令把race的值取到操作栈顶时，volatile关键字保证了race的值在此时是正确的，但是在执行iconst1、iadd这些指令的时候，其他线程可能已经把race的值加大了，而在操作栈顶的值就变成了过期的数据，所以putstatic指令执行后就可能把较小的race值同步回主内存之中。
    使用volatile变量的第二个语义是禁止指令重排序优化，普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序-致。因为在一个线程的方法执行过程中无法感知到这点，这也就是Java内存模型中描述的所谓的“线程内表现为串行的语义”(Within-Thread As-If-Serial Semantics)。
     Java内存模型中对volatile变量定义的特殊规则。假定T表示一个线程，V和W分别表示两个volatile型变量，那么在进行read、load、use、assign、store和write操作时需要满足如下的规则:
     1.只有当线程T对变量V执行的前一一个动作是load的时候，线程T才能对变量V执行use动作;并且，只有当线程T对变量V执行的后一个动作是use的时候，线程T才能对变量V执行load动作。线程T对变量V的use动作可以认为是与线程T对变量V的load和read动作相关联的，必须- -起连续出现。(这条规则要求在工作内存中，每次使用V前都必须先从主内存刷新最新的值，用于保证能看见其他线程对变量V所做的修改后的值)。
     2.只有当线程T对变量V执行的前一个动作是assign的时候，线程T才能对变量V执行store动作;并且，只有当线程T对变量V执行的后-个动作是store的时候，线程T才能对变量V执行assign动作。线程T对变量V的assign动作可以认为是与线程T对变量V的store和write动作相关联的，必须-起连续出现(这条规则要求在工作内存中，每次修改V后都必须立刻同步回主内存中，用于保证其他线程可以看到自己对变量V所做的修改)。
     3.假定动作A是线程T对变量V实施的use或assign动作，假定动作F是与动作A相关联的load或store动作，假定动作P是与动作F相应的对变量V的read或write动作;类似地，假定动作B是线程T对变量W实施的use或assign动作，假定动作G是与动作B相关联的load或store动作，假定动作Q是与动作G相应的对变量W的read或write动作。如果A先于B,那么P先于Q(这条规则要求volatile修饰的变量不会被指令重排序优化，保证代码的执行顺序与程序的顺序相同)。
     
  对于long和double型变量的特殊规则
      Java内存模型要求lock、unlock、 read、 load、 assign、 use、 store 和write这八个操作都具有原子性，但是对于64位的数据类型(long 和double),在模型中特别定义了一条宽松的规定:允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，即允许虚拟机实现选择可以不保证64位数据类型的load、store、read和write这四个操作的原子性，这点就是所谓的long和double的非原子性协定(Nonatomic Treatment of double and long Variables)。
      如果有多个进程共享一个并未声明为volatile的long或double类型的变量，并且同时对它们进行读取和修改操作，那么某些线程可能会读取到-一个既非原值，也不是其他线程修改值的代表了“半个变量”的数值。
      不过这种读取到“半个变量”的情况非常罕见，因为Java内存模型虽然允许虚拟机不把long和double变量的读写实现成原子操作，但允许虚拟机选择把这些操作实现为具有原子性的操作，而且还“强烈建议”虚拟机这样实现。在实际开发中，目前各种平台下的商用虚拟机几乎都选择把64位数据的读写操作作为原子操作来对待，因此我们在编写代码时-般不需要将用到的long和double变量专门声明为volatile。
      
  **原子性**( Atomicity):由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store和write这六个，我们大致可以认为基本数据类型的访问读写是具备原子性的。
    如果应用场景需要一个更大范围的原子性保证(经常会遇到)，Java 内存模型还提供了lock和unlock操作来满足这种需求，尽管虚拟机未把lock和unlock操作直接开放给用户使用，但是却提供了更高层次的字节码指令monitorenter和monitorexit来隐式地使用这两个操作，这两个字节码指令反映到Java代码中就是同步块一synchronized关键字，因此在synchronized块之间的操作也具备原子性。
  **可见性**(Visibility): 可见性就是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的，无论是普通变量还是volatile变量都是如此，普通变量与volatile变量的区别是volatile的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。因此我们可以说volatile保证了多线程操作时变量的可见性，而普通变量则不能保证这一点。
    除了volatile之外，Java还有两个关键字能实现可见性，它们是synchronized和final。同步块的可见性是由“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中(执行sotre和write操作)”这条规则获得的，而final关键字的可见性是指:被final修饰的字段在构造器中一日被初始化完成，并且构造器没有把“this”的引用传递出去(this引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象)，那么在其他线程中就能看见final 字段的值。




















        
























































    
 





    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    