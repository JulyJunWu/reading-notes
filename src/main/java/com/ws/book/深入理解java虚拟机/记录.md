从广义上讲，Clojure、 JRuby、 Groovy 等运行于Java虚拟机上的语言及其相关的程序都属于Java技术体系的-员。

我们可以把Java程序设计语言、Java 虚拟机、Java API类库这三部分统称为JDK(Java Development Kit)，JDK是用于支持Java程序开发的最小环境;

可以把Java API类库中的Java SE API子集和Java虚拟机这两部分统称为JRE (Java Runtime Environment)，JRE是支持Java程序运行的标准环境。

Java技术体系可以分为四个平台，分别为:
    1.Java Card:支持一些 Java小程序(Applets)运行在小内存设备 (如智能卡) 上的平台。
    2.Java ME( Micro Edition):支持Java程序运行在移动终端(手机、PDA)上的平台，对Java API有所精简，并加入了针对移动终端的支持，这个版本以前称为J2ME。
    3.JavaSE(Standard Edition):支持面向桌面级应用(如Windows下的应用程序)的Java平台，提供了完整的Java核心API,这个版本以前称为J2SE。
    4.Java EE (Enterprise Edition):支持使用多层架构的企业应用( 如ERP、CRM应用)的Java平台，除了提供JavaSEAPI外，还对其做了大量的扩充并提供了相关的
部署支持，这个版本以前称为J2EE。

Java语言的前身: Oak (橡树)。

1995年5月23日，Oak语言改名为Java,并且在SunWorld大会上正式发布了Java 1.0版本。Java 语言第一-次提出了“Write Once, Run Anywhere”的口号。

Scala、Clojure 及Erlang等天生就具备并行计算能力的语言。

在JDK1.6 Update 14之后，提供了普通对象指针压缩功能(-XX:+ UseCompressedOops)，在解释器解释字节码时，植入压缩指令以节省内存消耗。

运行时数据区: 查看运行时数据区.png
  程序计数器:
    程序计数器( Program Counter Register)是一块较小的内存空间，它的作用可以看做是`当前线程所执行的字节码的行号指示器。`在虚拟机的概念模型里(仅是概念模型，各种虚拟机可能会通过-些更高效的方式去实现)，字节码解释器工作时就是通过改变这个计数器的值来选取下-条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来成。
    由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器(对于多核处理器来说是一一个内核)只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“`线程私有`”的内存。
    如果线程正在执行的是一一个Java方法，`这个计数器记录的是正在执行的虚拟机字节码指令的地址`;如果正在执行的是Native方法，`这个计数器值则为空(Undefined)`。此内存区域是唯一一个在Java虚拟机规范中`没有规定任何OutOfMemoryError情况的区域`。
    
  Java虚拟机栈(Java Virtual Machine Stacks)
    线程私有的,生命周期与线程相同。`虚拟机栈描述的是Java方法执行的内存模型`:每个方法被执行的时候都会同时创建一个`栈帧`(Stack Frame”)用于`存储局部变量表、操作栈、动态链接、方法出口等`信息。`每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。`
    局部变量表存放了编译期可知的各种基本数据类型(boolean、 byte、 char、 short、 int、float、long、 double)、 对象引用(reference 类型，它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的`引用指针`，也可能指向一个代表对象的`句柄`或者其他与此对象相关的位置)`和returnAddress类型`(指向了一条字节码指令的地址)。
    64位长度的long和double类型的数据会占用2个`局部变量空间(Slot)`,其余的数据类型只占用1个。`局部变量表所需的内存空间在编译期间完成分配`，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，`在方法运行期间不会改变局部变量表的大小。`
     两种异常: 
        1.如果线程请求的栈深度大于虚拟机所允许的深度，将抛出`StackOverflowError`异常;
        2.如果虚拟机栈可以动态扩展(当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈)，当扩展时无法申请到足够的内存时会抛出`OutOfMemoryError`异常。
     栈帧是方法运行期的基础数据结构，

  本地方法栈(Native Method Stacks):
    与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法(也就是字节码)服务，而`本地方法栈则是为虚拟机使用到的Native方法服务`。虚拟机规范中对本地方法栈中的方法使用的语
言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机(譬如Sun HotSpot虚拟机)直接就把本地方法栈和虚拟机栈合二为一。
    `本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。`

 Java堆:
     对于大多数应用来说，Java堆(JavaHeap)是Java虚拟机所管理的内存中最大的一块。
     1.Java堆是`被所有线程共享`的一块内存区域，`在虚拟机启动时创建`。
     2.`此内存区域的唯一目的就是存放对象实例`，几乎所有的对象实例都在这里分配内存。这一点在Java虚拟机规范中的描述是:所有的对象实例以及数组都要在堆上分配”，但是随着JIT编译器的发展与`逃逸分析技术`的逐渐成熟，`栈上分配、标量替换`优化技术将会导致-些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。
     3.采用分代回收算法
     4.会出现OutOfMemoryError;
     Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆”(Garbage Collected Heap)。如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java堆中还可以细分为:`新生代和老年代`;再细致一点的有`Eden`空间、`From Survivor空间、To Survivor`空间等。如果从内存分配的角度看，线程共享的Java堆中可能划分出多个线程私有的`分配缓冲区`(ThreadLocalAllocation Buffer, TLAB)。 不过，无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例，进步划分的目的是为了更好地回收内存，或者更快地分配内存。
     -Xms , -Xmx
 
 方法区(Method Area):
    1.线程共享的内存区域
    2.用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。(Non-Heap (非堆))
    3.当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。
    4.垃圾回收器对这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载
    对于HotSpot很多人愿意把方法区称为“永久代”( Permanent Generation)，本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已。对于其他虚拟机来说是不存在永久代的概念的;
     Java虚拟机规范对这个区域的限制非常宽松，除了和Java堆样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字-样“永久”存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是有必要的。

 运行时常量池(Runtime Constant Pool):
    1.方法区的一部分。
    2.当常量池无法再申请到内存时会抛出OutOfMemoryError异常。
    Class文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池( Constant Pool Table)，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。
    对于运行时常量池，Java虚拟机规范没有做任何细节的要求，不同的提供商实现的虚拟机可以按照自己的需要来实现这个内存区域。不过，一般来说，除了保存Class文件中描述的符号引用外，还会把翻译出来的接引用也存储在运行时常量池中。
    运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只能在编译期产生，也就是并非预置人Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String 类的intern()方法。

 直接内存(Direct Memory):
    并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现.
    在JDK 1.4中新加入了NIO (New Input/Output)类，引入了一种基于通道(Channel)与缓冲区(Buffer) 的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。
    本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存(包括RAM及SWAP区或者分页文件)的大小及处理器寻址空间的限制。服务器管理员配置虚拟机参数时，一般会根据实际内存设置-Xmx等参数信息，但经常会忽略掉直接内存，使得各个内存区域的总和大于物理内存限制(包括物理上的和操作系统级的限制)，从而导致动态扩展时出现OutOfMemoryError异常。

 对象访问 : Object obj = new Object() 出现在方法体中;
    1.Object obj这部分的语义将会反映到Java栈的本地变量表中，作为一个reference 类型数据出现。
    2.new Object()这部分的语义将会反映到Java堆中，形成块存储了Object类型所有实例数据值(Instance Data,对象中各个实例字段的数据)的结构化内存，根据具体类型以及虚拟机实现的对象内存布局(Object Memory Layout)的不同，这块内存的长度是不固定的。另外，在Java堆中还必须包含能查找到此对象类型数据(如对象类型、父类、实现的接口、方法等)的地址信息，这些类型数据则存储在方法区中。
   不同虚拟机实现的对象访问方式会有所不同，主流的访问方式有两种:使用`句柄`和`直接指针`。
      1.如果使用句柄访问方式，Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息(句柄访问对象.png)。
      2.如果使用直接指针访问方式，Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference中直接存储的就是对象地址(直接指针访问对象.png)。
   这两种对象的访问方式各有优势:
        1.使用句柄访问方式的最大好处就是reference 中存储的是稳定的句柄地址，在对象被移动(垃圾收集时移动对象是非常普遍的行为)时只会改变句柄中的实例数据指针，而reference本身不需要被修改。
        2.使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。
        Sun HotSpot使用第二种方式进行对象访问;
 判断对象是否存活的算法:
    1.引用计数法
        给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1 ;当引用失效时，计数器值就减1 ;任何时刻计数器都为0的对象就是不可能再被使用的。
        引用计数算法(ReferenceCounting)的实现简单，判定效率也很高，但是`难以解决对象之间的相互循环引用的问题`。
    2.根搜索算法
        用根搜索算法(GC Roots Tracing)判定对象是否存活的。这个算法的基本思路就是通过一系列的名为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链( Reference Chain),当一个对象到GC Roots没有任何引用链相(用图论的话来说就是从GC Roots到这个对象不可达)时，则证明此对象是不可用的。
    在Java语言里，可作为GCRoots的对象包括下面几种:
        1.虚拟机栈(栈帧中的本地变量表)中的引用的对象。
        2.方法区中的类静态属性引用的对象。
        3.方法区中的常量引用的对象。
        4.本地方法栈中JNI (即一般说的Native方法)的引用的对象。
        
 在JDK1.2之后，Java对引用的概念进行了扩充，将引用分为强引用(Strong Reference)、软引用(Soft Reference)、弱引用( Weak Reference)、 虚引用( PhantomReference)四种，这四种引用强度依次逐渐减弱。
   1.`强引用`就是指在程序代码之中普遍存在的，类似“Object obj = new Objct()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。
   2.`软引用`用来描述- -些还有用，但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中并进行第二次回收。如果这次回收还是没有足够的内存，才会抛出内存溢出异常。在JDK1.2之后，提供了SoftReference类来实现软引用。
   3.`弱引用`也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2之后，提供了WeakReference类来实现弱引用。
   4.`虚引用`也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯目的就是希望能在这个对象被收集器回收时收到-一个系统通知。在JDK 1.2之后，提供了PhantomReference 类来实现虚引用。
 
 搜索算法回收对象的过程:
    在根搜索算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于 “缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程:如果对象在进行根搜索后发现没有与GC Roots相连接的引用链，那它将会被第次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。
    如果这个对象被判定为有必要执行finalize() 方法，那么这个对象将会被放置在-一个名为F-Queue的队列之中，并在稍后由一条由虚拟机自动建立的、低优先级的Finalizer线程去执行。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束。这样做的原因是，如果一个对象在finalize()方法中执行缓慢，或者发生了死循环(更极端的情况)，将很可能会导致F-Queue队列中的其他对象永久处于等待状态甚至导致整个内存回收系统崩溃。finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己一只要重新与引用链上的任何一个对象建立关联即可，譬如把自己(this关键字)赋值给某个类变量或对象的成员变量，那在第二次标记时它将被移除出“即将回收”的集合;如果对象这时候还没有逃脱，那它就真的离死不远了。
    另外一个值得注意的地方就是，`任何一个对象的finalize()方法都只会被系统自动调用一次`，如果对象面临下一次回收，它的finalize()方法不会被再次执行;
    
 如何判断一个类是否“无用的类":
    1.该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。
    2.加载该类的ClassLoader已经被回收。
    3.该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
    HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用
    -verbose:class : 查看类的是由哪个类加载器加载
    -XX:+TraceClassLoading : 查看类的加载
    -XX:+TraceClassUnLoading :查看类的卸载信息。

 垃圾收集算法:
     1.标记-清除算法
        最基础的收集算法是“标记-清除”(Mark-Sweep) 算法，如它的名字样，算法分 为“标记”和“清除”两个阶段:首先标记出所有需要回收的对象，在标记完成后统回收掉所有被标记的对象，它的标记过程其实在前之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其缺点进行改进而得到的。
        它的主要缺点有两个:
            一个是效率问题，标记和清除过程的效率都不高;
            另外一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而得不提前触发另一次垃圾收集动作。
     2.复制算法
        为了解决效率问题，一种称为“复制”(Copying)的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的-块。当这块的内存用完了，就将还存活着的对象复制到另外块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对其中的块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为原来的半，未免太高了一点。
        现在的商业虚拟机都采用这种收集算法来回收新生代，IBM的专门研究表明，新生代中的对象98%是朝生夕死的，所以并不需要按照1 :1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较Survivor空间，每次使用Eden和其中的一块Survivor”。当回收时，将Eden和Survivor中还存活着的对象一次性地拷贝到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor的空间。HotSpot虚拟
机默认Eden和Survivor的大小比例是8:1,也就是每次新生代中可用内存空间为整个新生代容量的90% ( 80%+10%)，只有10%的内存是会被“浪费”的。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存(这里指老年代)进行分配担保(Handle Promotion)。
    3.标记一整理算法
        复制收集算法在对象存活率较高时就要执行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。根据老年代的特点，有人提出了另外一种“标记-整理”(Mark-Compact)算法，标记过程仍然与“标记一清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存;
    4.分代收集算法
    当前商业虚拟机的垃圾收集都采用“分代收集”(Generational Collection)算法，种算法并没有什么新的思想，只是根据对象的存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记一清理”或“标记一整理”算法来进行回收。

 垃圾收集器:
    1.Serial收集器
      Serial收集器是最基本、历史最悠久的收集器，曾经(在JDK 1.3.1 之前)是虚拟机新生代收集的唯一选择。 大家看名字就知道，这个收集器是-一个单线程的收集器，但它的“单线程”的意义并不仅仅是说明它只会使用一一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程(Sun将这件事情称之为“Stop The World")，直到它收集结束。
      它也有着优于其他收集器的地方:简单而高效(与其他收集器的单线程比),对于限定单个CPU的环境来说，Serial 收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。在用户的桌面应用场景中，分配给虚拟机管理的内存一般来说不会很大，收集几十兆甚至一两百兆的新生代(仅仅是新生代使用的内存，桌面应用基本上不会再大了),停顿时间完全可以控制在几十毫秒最多一百多毫秒以内，只要不是频繁发生，这点停顿是可以接受的。所以，Serial 收集器对于运行在Client模式下的虚拟机来说是一个很好的选择。
    2.ParNew收集器
      ParNew收集器其实就是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为包括Serial收集器可用的所有控制参数(例如: -XX:SurvivorRatio、-XX:PretenureSizeThreshold、-XX:HandlePromotionFailure等 )、收集算法、Stop TheWorld、对象分配规则、回收策略等都与Serial收集器完全样，实现上这两种收集器也共用了相当多的代码。
      ParNew收集器除了多线程收集之外，其他与Serial收集器相比并没有太多创新之处，但它却是许多运行在Server模式下的虚拟机中首选的新生代收集器，其中有一个与性能无关但很重要的原因是，除了Serial收集器外，目前只有它能与CMS收集器配合工作。
      ParNew收集器也是使用-XX:+UseConcMarkSweepGC选项后的默认新生代收集器，也可以使用-XX:+UseParNewGC.选项来强制指定它。
      ParNew收集器在单CPU的环境中绝对不会有比Serial收集器更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个CPU的环境中都不能百分之百地保证能超越Serial收集器。当然，随着可以使用的CPU的数量的增加，它对于GC时系统资源的利用还是很有好处的。它默认开启的收集线程数与CPU的数量相同，在CPU非常多(譬如32个，现在CPU动辄就4核加超线程，服务器超过32个逻辑CPU的情况越来越多了)的环境下，可以使用-XX:ParallelGCThreads 参数来限制垃圾收集的线程数。
    3.ParallelScavenge收集器
        也是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器.....
        CMS等收集器的关注点尽可能地缩短垃圾收集时用户线程的停顿时间，而ParallelScavenge收集器的目标则是达到-一个可控制的吞吐量(Throughput)。
        所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)，虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户的体验;而高吞吐量则可以最高效率地利用CPU时间，尽快地完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。
        Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的-XX:MaxGCPauseMillis参数及直接设置吞吐量大小的-XX:GCTimeRatio参数。
    4.Serial Old收集器
      Serial Old是Serial 收集器的老年代版本，它同样是一个单线程收集器，使用“标记一整理”算法。这个收集器的主要意义也是被Client模式下的虚拟机使用。如果在Server模式下，它主要还有两大用途:一个是在JDK 1.5及之前的版本中与ParallelScavenge收集器搭配使用，另外一个就是作为CMS收集器的后备预案，在并发收集发生ConcurrentModeFailure的时候使用。
    5.Parallel Old收集器
      Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法.
      “吞吐量优先”收集器终于有了比较名副其实的应用组合，在注重吞吐量及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。
    6.CMS (Concurrent Mark Sweep)收集器
      是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用都集中在互联网站或B/S系统的服务端上,这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。
      从名字(包含“Mark Sweep")上就可以看出CMS收集器是基于“标记一清除”算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为4个步骤，包括:
        1.初始标记(CMS initial mark)
        2.并发标记(CMS concurrent mark)
        3.重新标记(CMS remark)
        4.并发清除(CMS concurrent sweep)
      其中初始标记、重新标记这两个步骤仍然需要“StopTheWorld"。初始标记仅仅只是标记一下GCRoots能直接关联到的对象，速度很快，并发标记阶段就是进行GCRootsTracing的过程，而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那--部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。
    三个显著缺点:
        1.对CPU资源非常敏感; 默认启动的回收线程数量 = (cpu数量+3)/4 ,当cu不足4个时,会导致用户线程变慢;
        2.无法处理浮动垃圾(Floating Garbage)
        3.产生大量碎片空间(因为是基于标准-清除算法);为了解决这个问题，CMS收集器提供了一个-XX:+UseCMSCompactAtFullCollection开关参数，用于在“享受”完FullGC服务之后额外免费附送一个碎片整理过程，内存整理的过程是无法并发的。空间碎片问题没有了，但停顿时间不得不变长了。虚拟机设计者们还提供了另外一个参数-XX: CMSFullGCsBeforeCompaction,这个参数用于设置在执行多少次不压缩的Full GC后，跟着来一次带压缩的。
    7.G1
        1.一是G1收集器是基于“标记-整理”算法实现的收集器，也就是说它 不会产生空间碎片;
        2.它可以非常精确地控制停顿，既能让使用者明确指定在一一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java(RTSJ)的垃圾收集器的特征了。
        G1收集器可以实现在基本不牺牲吞吐量的前提下完成低停顿的内存回收，这是由于它能够极力地避免全区域的垃圾收集，之前的收集器进行收集的范围都是整个新生代或老年代，而G1将整个Java堆(包括新生代、老年代划分为多个大小固定的独立区域(Region)，并且跟踪这些区域里面的垃圾堆积程度，在后台维护一个优先列表，每次根据允许的收集时间，优先回收垃圾最多的区域(这就是Garbage First名称的来由)。区域划分及有优先级的区域回收，保证了G1收集器在有限的时间内可以获得最高的收集效率。

 垃圾收集的常用参数:
    参数                                      描述
    UseSerialGC             虚拟机运行在Client模式下的默认值，打开此开关后，使用Serial +SerialOld的收集器组合进行内存回收;
    UseParNewGC             打开此开关后，使用ParNew+SerialOld的收集器组合进行内存回收;
    UseConcMarkSweepGC      打开此开关后，使用ParNew + CMS + Serial Old的收集器组合进行内存回收;
                            SerialOld收集器将作为CMS收集器出现ConcurrentModeFailure失败后的后备收集器使用,
    UseParallelGC           虚拟机运行在Server模式下的默认值，打开此开关后，使用Parallel Scavenge + Serial Old (PS MarkSweep的收集器组合进行内存回收;
    UseParallelOldGC        打开此开关后，使用Parallel Scavenge + Parallel Old的收集器组合进行内存回收
    SurvivorRatio           新生代中Eden区域与Survivor区域的容量比值，默认为8，代表Eden : Survivor-8: 1;
    PretenureSizeThreshold  直接晋升到老年代的对象大小，设置这个参数后，大于这个参数的对象将直接在老年代分配;
    MaxTenuringThreshold    晋升到老年代的对象年龄。每个对象在坚持过.次MinorGC之后，年龄就加1,当超过这个参数值时就进入老年代(默认是15);
    UseAdaptiveSizePolicy   动态调整Java堆中各个区域的大小以及进入老年代的年龄;
    HandlePromotionFailure  是否允许分配担保失败，即老年代的剩余空间不足以应付新生代的整个Eden和Survivor区的所有对象都存活的极端情况;
    ParallelGCThreads       设置并行GC时进行内存回收的线程数;
    GCTimeRatio             GC时间占总时间的比率，默认值为99,即允许1%的GC时间。仅在使用Parallel Scavenge收集器时生效;
    MaxGCPauseMillis        设置GC的最大停顿时间。仅在使用ParallelScavenge收集器时生效
    CMSInitiatingOccupancyFraction 设置CMS收集器在老年代空间被使用多少后触发垃圾收集。默认值为68%，仅在使用CMS收集器时生效
    UseCMSCompactAtFullCollection   设置CMS收集器在完成垃圾收集后是否要进行一次内存碎片整理。仅在使用CMS收集器时生效
    CMSFullGCsBeforeCompaction      设置CMS收集器在进行若干次垃圾收集后再启动一次内存碎片整理。仅在使用CMS收集器时生效

 -XX:+PrintGCDetails:告诉虚拟机在发生垃圾收集行为时打印内存回收日志，并且在进程退出的时候输出当前内存各区域的分配情况。在实际应用中，内存回收日志-般是打印到文件后通过日志工具进行分析;
 -Xms20M : 最小堆大小20M;
 -Xmx20M : 最大堆大20M;
 -Xmn10M : 年轻代大小10m;
 -XX:SurvivorRatio=8
 新生代GC(Minor GC):指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。
 老年代GC(Major GC/ Full GC):指发生在老年代的GC，出现了Major GC,经常会伴随至少一次的Minor GC(但非绝对的，在ParallelScavenge收集器的收集策略里就有直接进行Major GC的策略选择过程)。MajorGC的速度一般会比Minor GC慢10倍以上。
 
   `大对象直接进入老年代`: 所谓大对象就是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串及数组(笔者例子中的byte[] 数组就是典型的大对象)。大对象对虚拟机的内存分配来说就是一个坏消息(比遇到一个大对象更加坏的消息就是遇到一群“朝生夕灭”的“短命大对象”，写程序的时候应当避免)，经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”它们。虚拟机提供了一一个-XX:PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代中分配。这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存拷贝(复习一下:新生代采用复制算法收集内存)。

   `长期存活的对象将进入老年代`: 虚拟机给每个对象定义了一个对象年龄(Age)计数器。如果对象在Eden出生并经过第次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将对象年龄设为1。对象在Survivor区中每熬过一次 Minor GC,年龄就增加1岁，当它的年龄 增加到一定程度(默认为15岁)时，就会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数-XX:Max TenuringThreshold来设置。

   `动态对象年龄判定`: 为了能更好地适应不同程序的内存状况，虚拟机并不总是要求对象的年龄必须达到MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进人老年代，无须等到MaxTenuringThreshold中要求的年龄。

   `空间分配担保`:在发生Minor GC时，虚拟机会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间大小，如果大于，则改为直接进行一次Full GC。如果小于，则查看HandlePromotionFailure设置是否允许担保失败;如果允许，那只会进行Minor GC;如果不允许，则也要改为进行一次Full GC。新生代使用复制收集算法，但为了内存利用率，只使用其中一个Survivor空间来作为轮换备份，因此当出现大量对象在MinorGC后仍然存活的情况时(最极端就是内存回收后新生代中所有对象都存活),就需要老年代进行分配担保，让Survivor无法容纳的对象直接进入老年代。老年代要进行这样的担保，前提是老年代本身还有容纳这些对象的剩余空间，一共有多少对象会活下来，在实际完成内存回收之前是无法明确知道的，所以只好取之前每~次回收晋升到老年代对象容量的平均大小值作为经验值，与老年代的剩余空间进行比较，决定是否进行FullGC来让老年代腾出更多空间。取平均值进行比较其实仍然是一一种动态概率的手段，也就是说如果某次MinorGC存活后的对象突增，远远高于平均值的话，依然会导致担保失败(HandlePromotion Failure。如果出现了HandlePromotionFailure失败，那就只好在失败后重新发起一次FullGC。虽然担保失败时绕的圈子是最大的，但大部分情况下都还是会将HandlePromotionFailure开关打开，避免Full GC过于频繁;
  
 Sun JDK监控和故障处理工具:
     名称		主要作用
     jps		JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程
     jstat		JVM Statistics Monitoring Tool,用于收集HotSpot虚拟机各方面的运行数据
     jinfo		Configuration Info for Java,显示虚拟机配置信息
     jmap		MemoryMapforJava,生成虚拟机的内存转储快照(heapdump文件)
     jhat		JVM Heap Dump Browser, 用于分析heapdump文件，它会建立一个HTTP/HTML服务器，让用户可以在浏览器上查看分析结果
     jstack		Stack Trace for Java,显示虚拟机的线程快照

 jstat :虚拟机统计信息监视工具
    jstat (JVM Statistics Monitoring Tool)是用于监视虚拟机各种运行状态信息的命令行工具。它可以显示本地或远程虚拟机进程中的类装载、内存、垃圾收集、JIT 编译等运行数据，在没有GUI图形界面，只提供了纯文本控制台环境的服务器上，它将是运行期定位虚拟机性能问题的首选工具。
    jstat命令格式为: jstat [ option vmid [interval [s |ms] [count]] ]
    参数interval和count代表查询间隔和次数，如果省略这两个参数，说明只查询一次。假设需要每250毫秒查询次进程2764垃圾收集的状况，-共查询20次，那命令应当是:
        jstat -gc 2764 250 20 ; 更多参数请看 jstat工具主要选项.png
 jmap : Java内存映像工具
    jmap(MemoryMapforJava)命令用于生成堆转储快照(一般称为heapdump或dump文件)。jmap的作用并不仅仅是为了获取dump文件，它还可以查询finalize执行队列，Java堆和永久代的详细信息，如空间使用率、当前用的是哪种收集器等。
    jmap命令格式:   jmap [ option ] vmid
    参数: jmap工具主要选项.png
    
 JDK的可视化工具: JConsole和VisualVM

 在32位Windows平台中每个进程只能使用2GB的内存，考虑到堆以外的内存开销，堆一般最多只能开到1.5GB。在某些Linux, Unix系统(如Solaris) 中，可以提升到3GB乃至接近4GB的内存，但32位中仍然受最高4GB (2^32) 内存的限制。

 除了Java堆和永久代之外，下面这些区域还会占用较多的内存，这里所有的内存总和会受到操作系统进程最大内存的限制:
    1.Direct Memory :可通过-XX:MaxDirectMemorySize调整大小，内存不足时抛出OutOfMemoryError 或OutOfMemoryError: Direct buffer memory。
    2.线程堆栈:可通过-Xss调整大小，内存不足时抛出StackOverflowError (纵向无法分配，即无法分配新的栈帧)或OutOfMemoryError: unable to create new native thread(横向无法分配，即无法建立新的线程)。
    3.Socket缓存区:每个Socket连接都Receive和Send两个缓存区，分别占大约37KB和25KB的内存，连接多的话这块内存占用也比较可观。如果无法分配，则可能会抛出IOException: Too many open files 异常。
    4.JNI代码:如果代码中使用JNI调用本地库，那本地库使用的内存也不在堆中。
    5.虚拟机和GC:虚拟机和GC的代码执行也要消耗一定的内存。

 通过Java的Runtime.getRuntime().exec()方法可以用来调用shell脚本。但是它在Java虚拟机中非常消耗资源，即使外部命令本身能很快执行完毕，频繁调用时创建进程的开销也非常可观。Java虚拟机执行这个命令的过程是:首先克隆一个和当前虚拟机拥有一样环境变量的进程，再用这个新的进程去执行外部命令，最后再退出这个进程。如果频繁执行这个操作，系统的消耗会很大，不仅是CPU,内存的负担也很重。
 
参数-Xverify:none : 禁止字节码验证过程,意思为不需要在加载的时候再进行字节码验证
查看类加载所消耗时间 : jstat -class pid

   编译时间 : 是指虚拟机的JIT编译器(Just In Time Compiler)编译热点代码(Hot Spot Code)的耗时。我们知道Java语言为了实现跨平台的特性，Java代码编译出来后形成的Class文件中储存的是字节码(ByteCode)，虚拟机通过解释方式执行字节码命令，比起C/C++编译成本地二进制代码来说，速度要慢不少。为了解决程序解释执行的速度问题，JDK1.2以后，虚拟机内置了两个运行时编译器”，如果一-段Java方法被调用的次数到达一定程度，就会被判定为热代码，从而交给JIT编译器即时编译为本地代码，以提高运行速度(这就是HotSpot虚拟机名字的由来)。甚至有可能在运行期动态编译比C/C++的编译器静态编译出来的代码更优秀，因为运行期可以收集很多编译器无法知道的信息，甚至可以采用一些很激进的优化手段，在优化条件不成立的时候再逆优化退回来。所以Java程序只要代码没有问题(主要是泄漏问题，如内存泄漏、连接泄漏)，随着代码被编译得越来越彻底，运行速度应当是越来越快。Java运行期编译最大的缺点就是编译需要消耗程序正常的运行时间，也就是上面所说的“编译时间”。

参数 -XX:+DisableExplicitGC : 屏蔽掉System.gc()。
ParNew收集器是使用CMS收集器后的默认新生代收集器;
CMS默认老年代使用了68%就进行收集，使用-XX:CMSInitiatingOccupancyFraction=85将GC临界值提升到85%;

   实现语言无关性的基础是虚拟机和字节码存储格式，使用Java编译器可以把Java代码编译为存储字节码的Class文件，使用JRuby等其他语言的编译器样可以把程序代码编译成Class文件，虚拟机并不关心Class的来源是什么语言，只要它符合Class文件应有的结构就可以在Java虚拟机中运行;

Class文件格式.png

魔数与Class文件的版本
    每个Class文件的头4个字节称为魔数(MagicNumber),它的唯一作用是用于确定这个文件是否为一个能被虚拟机接受的Class文件。很多文件存储标准中都使用魔数来进行身份识别，譬如图片格式，如gif 或jpeg等在文件头中都存有魔数。使用魔数而不是扩展名来进行识别主要是基于安全考虑，因为文件扩展名可以很随意地被改动。文件格式的制定者可以自由地选择魔数值，只要这个魔数值还没有被广泛采用过而且不会引起混淆即可。Class文件的魔数值为: 0xCAFEBABE;
    紧接着魔数的4个字节存储的是Class文件的版本号:第5和第6个字节是次版本号(Minor Version),第7个和第8个字节是主版本号(Major Version)。Java 的版本号是从45开始的，JDK1.1能支持版本号为45.0 ~ 45.65535的Class,无法执行版本号为46.0以上的Class,而JDK 1.2则能支持45.0~46.65535的Class文件。JDK版本为1.7为51,jdk1.8为52;

制定Class文件格式规范时，将第0项常量空出来是有特殊考虑的，这样做是为了满足后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的意思，这种情况就可以把索引值置为0来表示。Class文件结构中只有常量池的容量计数是从1开始的，对于其他集合类型，包括接口索引集合、字段表集合、方法表集合等的容量计数都与一般习惯相同，是从0开始的。

由于Class文件中方法、字段等都需要引用CONSTANT _Utf8_ info型常量来描述名称，所以CONSTANTUtf8_info型常量的最大长度也就是`Java中方法和字段名的最大长度`。而这里的最大长度就是length的最大值，即u2类型能表达的最大值`65535`。所以Java程序中如果定义了超过64KB英文字符的变量或方法名，将会无法编译。

常量池11中数据类型的结构总表.png
访问标志.png

数组类型，每一维度将使用一个前置的“[”字符来描述，如一个定义为“java.lang.String[][]"类型的二维数组，将被记录为:“[[Ljava/lang/String;",
一个整型数组“int[]”将被记录为“[I”。

在Java语言中字段是无法重载的，两个字段的数据类型、修饰符不管是否相同，都必须使用不一一样的名称，但是对于字节码来讲，如果两个字段的描述符不一致，那字段重名就是合法的。

父类方法在子类中没有被重写(Override),方法表集合中就不会出现来自父类的方法信息。但同样的，有可能会出现由编译器自动添加的方法，最典型的便是类构造器“<clinit>"方法和实例构造器“<init>"方法”。

在Java语言中，要重载(Overload)一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的`特征签名`，特征签名就是一个方法中各个参数在常量池中的字段符号引用的集合，也就是因为返回值不会包含在特征签名之中，因此Java语言里面是无法仅仅依靠返回值的不同来对一个已有方法进行重载的。但是在Class文件格式之中，特征签名的范围更大一些，只要描述符不是完全一致的两个方法也可以共存。也就是说，如果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法共存于同一个Class文件中的。

Java代码的方法特征签名只包括了方法名称、参数顺序及参数类型，而字节码的特征签名还包括方法返回值及受查异常表。
方法属性表.png

Slot是虚拟机为局部变量分配内存所使用的最小单位。对于byte、char、float、int、short、boolean、 reference 和returnAddress等长度不超过32位的数据类型，每个局部变量占用1个Slot,而double和long这两种64位的数据类型则需要2个Slot来存放。

局部变量表(max_locals表示局部变量表的长度) : 并不是在方法中用到了多少个局部变量，就把这些局部变量所占的Slot之和作为max_locals的值，原因是局部变量表中的Slot可以重用，当代码执行超出一个局部变量的作用域时，这个局部变量所占的Slot就可以被其他局部变量所使用，编译器会根据变量的作用域来分类Slot并分配给各个变量使用，然后计算出max locals的大小。

code_ length(方法体的长度) : 虽然它是一个u4类型的长度值，理论上最大值可以达到232-1,但是虚拟机规范中限制了一个方法不允许超过65535条字节码指令，如果超过这个限制，Javac编译器就会拒绝编译.一般来讲，只要我们写Java代码时不是刻意去编写超长的方法，就不会超过这个最大值的限制。但是，在编译复杂的JSP文件时，可能会因为这个原因而导致编译失败。

字节码指令具体描述请看oracle网站 : https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.dup

类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括了:加载(Loading)、验证(Verification)、 准备( Preparation)、解析(Resolution)、初始化(Initialization)、 使用(Using)和卸载(Unloading)七个阶段。其中验证、准备和解析三个部分统称为连接(Linking)

加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定:它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定(也称为动态绑定或晚期绑定).

对于初始化阶段，虚拟机规范则是严格规定了有且只有四种情况必须立即对类进行“初始化”:
    1)遇到new、getstatic、 putstatic 或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是:使用new关键字实例化对象的时候、读取或设置一个类的静态字段(被final修饰、已在编译期把结果放人常量池的静态字段除外)的时候，以及调用一个类的静态方法的时候。
    2)使用java.lang.reflect包的方法对类进行发射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。
    3)当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
    4)当虚拟机启动时，用户需要指定一个要执行的主类(包含main()方法的那个类)，虚拟机会先初始化这个主类(启动类)。
    对于这四种会触发类进行初始化的场景，虚拟机规范中使用了一个很强烈的限定语:“有且只有”，这四种场景中的行为称为对一个类进行`主动引用`。除此之外所有引用类的方式，都不会触发初始化，称为`被动引用`。
    
对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。至于是否要触发子类的加载和验证，在虚拟机规范中并未明确规定，这点取决于虚拟机的具体实现。对于Sun HotSpot虚拟机来说，可通过-XX:+TraceClassLoading参数看到此操作会导致子类的加载。

引用非本类中的常量HELLOWORLD,在编译阶段会将此常量的值"hello world"存储到了本类的常量池中，对其他类的常量的引用实际都被转化为本类对自身常量池的引用了。也就是说实际上
本类的Class文件之中并没有其他类的符号引用人口，这两个类在编译成Class之后就不存在任何联系了。

当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候(如引用接口中定义的常量)才会初始化。

在**加载**阶段，虚拟机需要完成以下三件事情:
    1)通过一个类的全限定名来获取定义此类的二进制字节流。
    2)将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
    3)在Java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问人口。

**验证**是连接阶段的第-一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

**准备**阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配。

**解析**阶段是虚拟机将常量池内的符号引用替换为直接引用的过程;在Class文件中它以CONSTANT_Class_ info、CONSTANT Fieldref info、CONSTANT Methodref info等类型的常量出现，
    符号引用(Symbolic References):符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不定已经加载到内存中。
    直接引用(Direct References):直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在内存中存在。
    虚拟机规范之中并未规定解析阶段发生的具体时间，只要求了在执行anewarray、checkcast、getfield、 getstatic、 instanceof、 invokeinterface、 invokespecial、 invokestatic、invokevirtual、multianewarray、 new、putfield 和putstatic这13个用于操作符号引用的字节码指令之前，先对它们所使用的符号引用进行解析。所以虚拟机实现会根据需要来判断，到底是在类被加载器加载时就对常量池中的符号引用进行解析，还是等到一个符号引用将要被使用前才去解析它。

解析动作主要针对类或接口、字段、类方法、接口方法四类符号引用进行，分别对应于常量池的CONSTANT Class_ info、 CONSTANT Fieldref_ info、CONSTANT Methodref_info及CONSTANT InterfaceMethodref_ info 四种常量类型”。
    `1.类或接口的解析`
      假设当前代码所处的类为D,如果要把一个从未解析过的符号引用N解析为一个类或接口C的直接引用，那虚拟机完成整个解析的过程需要包括以下3个步骤:
      1.1)如果C不是一个数组类型，那虚拟机将会把代表N的全限定名传递给D的类加载器去加载这个类C。在加载过程中，由于无数据验证、字节码验证的需要，又将可能触发其他相关类的加载动作，例如加载这个类的父类或实现的接口。一旦这个加载过程出现了任何异常，解析过程就将宣告失败。
      1.2)如果C是一个数组类型，并且数组的元素类型为对象，也就是N的描述符会是类似“[Ljava.lang.Integer”的形式，那将会按照第1点的规则加载数组元素类型。如果N的描述符如前面所假设的形式，需要加载的元素类型就是“java.lang.Integer", 接着由虚拟机生成一个代表此数组维度和元素的数组对象。
      1.3)如果上面的步骤没有出现任何异常，那么C在虚拟机中实际上已经成为一个有效的类或接口了，但在解析完成之前还要进行符号引用验证，确认C是否具备对D的访问权限。如果发现不具备访问权限，将抛出java.langlllegalAccessError异常。
    `2.字段解析`
      要解析一个未被解析过的字段符号引用，首先将会对字段表内class index”项中索引的CONSTANT Class_ info 符号引用进行解析，也就是字段所属的类或接口的符号引用。如果在解析这个类或接口符号引用的过程中出现了任何异常，都会导致字段符号引用解析的失败。如果解析成功完成，那将这个字段所属的类或接口用C表示，虚拟机规范要求按照如下步骤对C进行后续字段的搜索:
      2.1)如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。
      2.2)否则，如果在C中实现了接口，将会按照继承关系从上往下递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。
      2.3)否则，如果C不是java.lang.Object的话，将会按照继承关系从上往下递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。
      2.4)否则，查找失败，抛出java.lang.NoSuchFieldError异常。如果查找过程成功返回了引用，将会对这个字段进行权限验证，如果发现不具备对
字段的访问权限，将抛出java.langlllegalAccessError异常。
    在实际应用中，虚拟机的编译器实现可能会比上述规范要求得更加严格一些，如果有一个同名字段同时出现在C的接口和父类中，或者同时在自己或父类的多个接口中出现，那编译器将可能拒绝编译。
    `3.类方法解析`
      类方法解析的第一个步骤与字段解析一样，也是需要先解析出类方法表的class_index项中索引的方法所属的类或接口的符号引用，如果解析成功，依然用C表示这个类，接下来虚拟机将会按照如下步骤进行后续的类方法搜索:
      3.1)类方法和接口方法符号引用的常量类型定义是分开的，如果在类方法表中发现class index中索引的C是个接口，那就直接抛出java.lang. IncompatibleClassChangeError
异常。
      3.2)如果通过了第(1)步，在类C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。
      3.3)否则，在类C的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。
      3.4)否则，在类C实现的接口列表及它们的父接口之中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果存在匹配的方法，说明类C是一个抽象类，这时候查找结束，抛出java.lang. AbstractMethodError异常。
      3.5)否则，宣告方法查找失败，抛出java.lang. NoSuchMethodError。
      最后，如果查找过程成功返回了直接引用，将会对这个方法进行权限验证;如果发现不具备对此方法的访问权限，将抛出java.lang.IllegalAccessError异常。
   ` 4.接口方法解析`
      接口方法也是需要先解析出接口方法表的classindex"项中索引的方法所属的类或接口的符号引用，如果解析成功，依然用C表示这个接口，接下来虚拟机将会按照如下
步骤进行后续的接口方法搜索:
      4.1)与类方法解析相反，如果在接口方法表中发现class _index 中的索引C是个类而不是接口，那就直接抛出java.lang. IncompatibleClassChangeError 异常。
      4.2)否则，在接口C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。
      4.3)否则，在接口C的父接口中递归查找，直到javalang.Object类(查找范围会包括Object类)为止，看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。
      4.4)否则，宣告方法查找失败，抛出java.lang. NoSuchMethodError异常。
      由于接口中的所有方法都默认是public的，所以不存在访问权限的问题，因此接口方法的符号解析应当不会抛出java.lan.llegalAccessError异常。

类**初始化**阶段是类加载过程的最后一步;到了初始化阶段，才真正开始执行类中定义的Java程序代码(或者说是字节码)。在准备阶段，变量已经赋过-次 系统要求的初始值， 而在初始化阶段，则是根据程序员通过程序制定的主观计划去初始化类变量和其他资源;

**clinit说明:**
   1. <clinit>(方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块(static{}块)中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块中可以赋值，但是不能访问。
   2. <clinit>(方法与类的构造函数(或者说实例构造器<init>(方法)不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的<clinit>0方法执行之前，父类 的<clinit>()方法已经执行完毕。因此在虚拟机中第一个 被执行的<clinit>( 方法的类肯定是java.lang.Object.
   3. 由于父类的<clinit>0方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作;
   4. <clinit>(方法对于类或接口来说并不是必须的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<clinit>O 方法。
   5. 接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成<clinit>方法。但接口与类不同的是，执行接口的<clinit>()方法不需要先执行父接口的<clinit>O方法。只有当父接口中定义的变量被使用时父接口才会被初始化。另外，接口的实现类在初始化时也一样不会执行接口的<clinit>()方法。
   6. 虚拟机会保证一个类的<clinit>方法在多线程环境中被正确地加锁和同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>方法，其他线程都需要阻塞等待，直到活动线程执行<clinit>方法完毕。如果在一个类的<clinit>方法中有耗时很长的操作，那就可能造成多个进程阻塞，在实际应用中这种阻塞往往是很隐蔽的。











































    
 





    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    