此书基于redis版本2.6.9

redis是remote dictionary server (远程字典服务器)的缩写，它以字典结构存储数据，并允许其他应用通过tcp协议读写字典中的内容。同大多数脚本语言中的字典样，redis 
字典中的键值除了可以是字符串，还可以是其他数据类型。redis支持的键值数据类型如下:
    ●字符串类型
    ●散列类型
    ●列表类型
    ●集合类型
    ●有序集合类型
    
redis数据库中的所有数据都存储在内存中。由于内存的读写速度远快于硬盘，因此redis在性能上对比其他基于硬盘存储的数据库有非常明显的优势，在一台普通的笔记本电
脑上，redis可以在一秒内读写超过十万个键值。

redis 约定次版本号(即第一个小数点后的数字)为偶数的版本是稳定版(如2.4版、2.6版)，奇数版本是非稳定版(如2.5 版、2.7 版),推荐使用稳定版本进行开发和在生产环境使用。

redis可执行文件说明:
    文件名             说明
   redis-server     redis服务器
   redis-cli        redis命令行客户端
   redis-benchmark  redis 性能测试工具
   redis-check-aof  aof文件修复工具
   redis-check-dump rdb文件检查工具

启动redis有直接启动和通过初始化脚本启动两种方式，分别适用于开发环境和生产环境。
    1.直接启动
      直接运行redis-server即可启动redis,十分简单:
      redis服务器默认会使用6379端口，通过--port参数可以自定义端口号:
      $>redis-server --port 6380
      6379是手机键盘上merz对应的数字，merz是一名意大利歌女的名字。
    2.通过初始化脚本启动redis
      在linux系统中可以通过初始化脚本启动redis,使得redis能随系统自动运行，在生产环境中推荐使用此方法运行redis;

停止redis:
    考虑到redis有可能正在将内存中的数据同步到硬盘中，强行终止redis进程可能会导致数据丢失。正确停止redis的方式应该是向redis发送shutdown命令，方
法为:$> redis-cli shutdown
    当redis收到shutdown命令后，会先断开所有客户端连接，然后根据配置执行持久化，最后完成退出。
    redis可以妥善处理sigterm信号，所以使用“kill redis进程的pid”也可以正常结束redis,效果与发送shutdown命令样。

发送命令:
    1.是将命令作为redis-cli的参数执行，比如redis-cli shutdown,redis-cli执行时会自动按照默认配置(服务器地址为127.0.0.1, 端口号为6379)连接redis,
    通过-h和-p参数可以自定义地址和端口号: $>redis-cli -h 127.0.0.1 -p 6379
    redis提供了ping命令来测试客户端与redis的连接是否正常，如果连接正常会收到回复pong。如:
    $>redis-cli ping
      pong
    2.是不附带参数运行redis-cli, 这样会进入交互模式，可以自由输入命令， 例如:$ redis-cli

命令返回值:
    在大多数情况下，执行一条命令后我们往往会关心命令的返回值，命令的返回值有5种类型，对于每种类型redis-cli的展现结果都不同，下面分别说明。
    1.状态回复
      状态回复(status reply)是最简单的种回复，比如向redis发送set命令设置某个键的值时，redis会回复状态ok表示设置成功。另外之前演示的对ping命令的回复pong
也是状态回复。状态回复直接显示状态信息，例如:
      redis> ping 
      pong
    2.错误回复
      当出现命令不存在或命令格式有错误等情况时redis会返回错误回复(error reply)。错误回复以(error)开头，并在后面跟上错误信息。如执行一个不存在的命令:
      redis> errorcommend
      (error) err unknown command 'errorcommend'
    3.整数回复
      redis虽然没有整数类型，但是却提供了一些用于整数操作的命令,如递增键值的incr命令会以整数形式返回递增后的键值。除此之外，一些其他命令也会返回整数，如可以获
取当前数据库中键的数量的dbsize命令等。整数回复(integer reply) 以(integer)开头，并在后面跟上整数数据:
      redis> incr foo
      (integer) 1
    4.字符串回复
      字符串回复(bulk reply)是最常见的种回复类型，当请求一个字符串类型键的键值或一个其他类型键中的某个元素时就会得到一个字符串回复。字符串回复以双引号包裹:
        redis> get foo
        "1”
      特殊情况是当请求的键值不存在时会得到一个空结果，显示为(nil)。如:
        redis> get noexists
        (ni1) 
    5.多行字符串回复
      多行字符串回复(multi-bulk reply) 同样很常见，如当请求个 非字符串类型键的元素列表时就会收到多行字符串回复。多行字符串回复中的每行字符串都以个序号开头，
      如:
        redis> keys *
        1)"bar"
        2) "foo"
        
在redis运行时通过config set命令在不重新启动redis的情况下动态修改部分redis配置。就像这样:
    redis> config set loglovel warning
    ok
同样在运行的时候也可以使用config get命令获得redis当前的配置情况，
例如:
    redis> config get 1oglavel
    11 "loglevel"
    2) "warning"
    
redis是一个字典结构的存储服务器，redis实例提供了多个用来存储数据的字典，客户端可以指定将数据存储在哪个字典中。这与我们熟知的在一个
关系数据库实例中可以创建多个数据库类似，所以可以将其中的每个字典都理解成个独立的数据库。
    每个数据库对外都是以一个从0开始的递增数字命名，redis默认支持16个数据库，可以通过配置参数databases来修改这一数字。客户端与redis建立连接后会
自动选择0号数据库，不过可以随时使用select命令更换数据库，如要选择1号数据库:
    redis> select 1
    ok
    redis[1]> get foo
    (ni1)
    redis不支持自定义数据库的名字，每个数据库都以编号命名，开发者必须自己记录哪些数据库存储了哪些数据。另外redis也不支持为每个数据库设置不同的访问密码，
所以一个客户端要么可以访问全部数据库，要么连一个数据库也没有权限访问。最重要的一点是多个数据库之间并不是完全隔离的，比如flushall命令可以清空一个redis实
例中所有数据库中的数据。

redis非常轻量级，一个空redis实例占用的内存只有1mb左右，所以不用担心多个redis实例会额外占用很多内存。

keys命令需要遍历redis中的所有键，当键的数量较多时会影响性能，不建议在生产环境中使用。

redis不区分命令大小写。

命令:
    type key: 用来获得键值的数据类型，返回值可能是string (字符串类型)、hash(散列类型)、list (列表类型)、set (集合类型)、zset (有序集合类型)。
    append key value : 向尾部追加值;
    strlen key : 获取字符串长度;

redis 提供了4个命令可以直接对二进制位进行操作:
        getbit key offset
        setbit key offset value
        bitcount key [start][end]
        bitop operation destkey key [key j


字符串类型是redis中最基本的数据类型，它能存储任何形式的字符串，包括二进制数据。你可以用其存储用户的邮箱、json化的对象甚至是-张图片。-个字符串类型键
允许存储的数据的最大容量是512mb。
字符串类型是其他4种数据类型的基础，其他数据类型和字符串类型的差别从某种角度来说只是组织字符串的形式不同。例如，列表类型是以列表的形式组织字符串，而
集合类型是以集合的形式组织字符串。

redis命令都是原子操作;

redis对于键的命名并没有强制的要求，但比较好的实践是用“对象类型:对象id:对象属性”来命名一个键，如使用键user:1:friends。对于多个单词则推荐使用“.” 分隔;

redis中每个键都属于一一个明确的数据类型，如通过hset命令建立的键是散列类型，通过set命令建立的键是字符串类型等。使用一种数据类型的命令操作另一
种数据类型的键会提示错误: "err operation against a key holding the wrong kind of value"

当字段不存在时赋值: hsetnx key field value ,不存在则赋值,否则hsetnx命令将不执行任何操作。

列表类型(list)可以存储一个有序的字符串列表，常用的操作是向列表两端添加元素，或者获得列表的某一个片段。
列表类型内部是使用双向链表( double linked list)实现的，所以向列表两端添加元素的时间复杂度为0(1),获取越接近两端的元素速度就越快。这意味着即使是一个有几千万
个元素的列表，获取头部或尾部的10条记录也是极快的(和从只有20个元素的列表中获取头部或尾部的10条记录的速度是样的)。
与散列类型键最多能容纳的字段数量相同，-个列表类型键最多能容纳23^2-1个元素。

集合间运算:
    sdiff key [key ...]
    sinter key [key ...]
    sunion key ikey ...]

进行集合运算并将结果存储:
    sdiffstore destination key [key ...]
    sinterstore destination key [key ...]
    sunionstore destination key [key ...]
    sdiffstore命令和sdiff命令功能样，唯一的区别就是前者不会直接返回运算
    结果，而是将结果存储在destination键中。

随机获得集合中的元素:
    srandmember key [count]
    srandmember命令用来随机从集合中获取多个元素，还可以传递count参数来一次随机获得多个元素，根据count的正负不同，具体表现
也不同。
    (1)当count为正数时，srandmember会随机从集合里获得count个不重复的元素。如果count的值大于集合中的元素个数，则srandmember会返回集合中的全部元素。
    (2)当count为负数时，srandmember会随机从集合里获得|count|个的元素,这些元素有可能相同。

有序集合类型(sorted set) 的特点从它的名字中就可以猜到，它集合类型(set)的区别就是“有序”二字。在集合类型的基础上有序集合类型为集合中的每个元素都关联了一个分数，
这使得我们不仅可以完成插入、删除和判断元素是否存在等集合类型支持的操作，还能够获得分数最高(或最低)的前n个元素、获得指定分数范围内的元素等与分数有关的操作。虽然集
合中每个元素都是不同的，但是它们的分数却可以相同。有序集合类型在某些方面和列表类型有些相似。
    (1)二者都是有序的。
    (2)二者都可以获得某一范围的元素。
    但是二者有着很大的区别，这使得它们的应用场景也是不同的。
    (1)列表类型是通过链表实现的，获取靠近两端的数据速度极快，而当元素增多后，
    访问中间数据的速度会较慢，所以它更加适合实现如“新鲜事”或“日志”这样很少访
    问中间元素的应用。
    (2)有序集合类型是使用散列表和跳跃表(skip list)实现的，所以即使读取位于中间
    部分的数据速度也很快(时间复杂度是o(log(n))。
    (3)列表中不能简单地调整某个元素的位置，但是有序集合可以(通过更改这个
    元素的分数)。
    (4)有序集合要比列表类型更耗费内存。
    有序集合类型算得上是redis的5种数据类型中最高级的类型了;
   
   zinterstore命令用来计算多个有序集合的交集并将结果存储在destination键中(同样以有序集合类型存储)，返回值为destination键中的元素个数。

事物:
    redis中的事务(transaction) 是一组命令的集合。事务同命令样都是redis的最小执行单位，一个事务中的命令要么都执行，要么都不执行。
    事务的原理是先将属于一个事务的命令发送给redis,然后再让redis依次执行这些命令。
    例如:
        redis> multi(开启事务)
        ok
        redis> sadd "user:1:following" 2
        queued(暂存队列)
        redis> sadd "user:2:followers" 1
        queued(暂存队列)
        redis> exec(执行操作)
        1) (integer) 1
        2) (integer) 1
    redis保证一个事务中的所有命令要么都执行，要么都不执行。如果在发送exec命令前客户端断线了，则redis会清空事务队列，事务中的所有命令都不会执行。而一旦客户
端发送了exec命令，所有的命令就都会被执行，即使此后客户端断线也没关系，因为redis中已经记录了所有要执行的命令。

错误处理:
    (1)在multi命令后执行了3个命令:一个是正确的命令，成功地加入事务队列:其余两个命令都有语法错误。而只要有一个命令有语法错误，执行exec命令后redis就会直
接返回错误，连语法正确的命令也不会执行。
    (2)运行错误。运行错误指在命令执行时出现的错误，比如使用散列类型的命令操作集合类型的键，这种错误在实际执行之前redis 是无法发现的，所以在事务里这样的命令
是会被redis 接受并执行的。如果事务里的一条命令出现了运行错误，事务里其他的命令依然会继续执行(包括出错命令之后的命令);
    redis的事务没有关系数据库事务提供的回滚(rollback) 功能.

watch:
    watch命令可以监控个或多个键，旦其中有 一个键被修改(或删除),之后的事务 就不会执行。监控直持续到exec命令(事务中的命令是在exec之后才执行的，
所以在multi命令后可以修改watch监控的键估)。
    由于watch命令的作用只是当被监控的键值被修改后阻止之后一个事务的执行，而不能保证其他客户端不修改这一键值，所以我们需要在exec执行失败后重新执行整个函数。
    执行exec命令后会取消对所有键的监控，如果不想执行事务中的命令也可以使用unwatch命令来取消监控。

过期时间:
    在redis中可以使用expire命令设置一个键的生存时间，到时间后redis会自动删除它。
    expire命令的使用方法为expire key seconds, 其中seconds参数表示键的生存时间，单位是秒。
    如果想取消键的生存时间设置(即将键恢复成永久的)，可以使用persist命令。 格式 : persist key;
    使用set或getset命令为键赋值也会同时清除键的生存时间; 其他只对键值进行操作的命令(如incr、lpush、hset、zrem)均不会影响键的生存时间。
    expire命令的seconds参数必须是整数，所以最小单位是1秒。如果想要更精确的控制键的生存时间应该使用pexpire命令，pexpire命令与expire的唯一区别是前
者的时间单位是毫秒，即pexpire key 1000与expire key 1等价。对应地可以用pttl命令以毫秒为单位返回键的剩余时间。
    如果使用watch命令监测了一个拥有生存时间的键，该键时间到期自动删除并不会被watch命令认为该键被改变。
    expireat命令与expire命令的差别在于前者使用unix时间作为第二个参数表示键的生存时间的截止时间。pexpireat 命令与expireat命令的区别是前者的时间单位是毫秒.
        redis>set foo bar
        ok
        redis> expireat foo 1351858 600
        (integer) 1
        redis> ttl foo
        (integer) 142
        redis> pexpireat foo 1351858700000
        (integer) 1

设置redis内存大小:修改配置文件的maxmemory参数，限制redis最大可用内存大小(单位是字节)，当超出了这个限制时redis会依据maxmemory-policy参数指定的策
略来删除不需要的键，直到redis占用的内存小于指定内存。
    maxmemory-polic策略:
            规则                          说明
        volatile-lru        使用lru算法删除一个键(只对设置了生存时间的键)
        al1keys-lru         使用lru算法删除一个键
        volatile- random    随机删除一个键(只对设置了生存时间的键)
        all keys-random     随机删除个键
        volatile-ttl        删除生存时间最近的一个键
        noeviction          不删除键，只返回错误(默认)
  如当maxmemory-policy设置为allkeys-lru 时，一旦redis占用的内存超过了限制值，redis会不断地删除数据库中最近最少使用的键，直到占用的内存小于限制值。
  事实上redis并不会准确地将整个数据库中最久未被使用的键删除，而是每次从数据库中随机取5个键井删除这5个键中最久未被使用的键。删除生存时间最接近的键的实现方法也是这样。“5”这个数字可以通过redis的配置文件中的maxmemory-samples参数设置。

sort排序: sort key
   sort命令可以对列表类型、集合类型和有序集合类型键进行排序，并且可以完成与关系数据库中的连接查询相类似的任务。
   除了可以排列数字外，sort命令还可以通过alpha参数实现按照字典顺序排列非数字元素，就像这样:
       redis> sort mylistalpha alpha
       1) "a"
       2) "b"
   sort命令的desc参数可以实现将元素按照从大到小的顺序排列:
      redis> sort key desc
   sort命令还支持limit参数来返回指定范围的结果。用法和sql语句一样，limit offset count,表示跳过前offset个元素并获取之后的count个元素。
      redis> sort tag: ruby:posts desc limit 1 2
        1) "12"
        2) "6"

使用redis实现任务队列: brpop listkey 0
    当列表中没有元素时brpop命令会直阻塞住连接，直到有新元素加入。
    brpop命令接收两个参数，第一个是键名，第二个是超时时间，单位是秒。当超过了此时间仍然没有获得新元素的话就会返回nil.上例中超时时间为“0”，表示不限制等待
的时间，即如果没有新元素加入列表就会永远阻塞下去。
    brpop命令可以同时接收多个键，其完整的命令格式为blpop key [key..] timeout,如blpop queue1 queue2 0。意义是同时检测多个键，如果所有键都没有元素
则阻塞，如果其中有一个键有元素则会从该键中弹出元素。

发布/订阅模式:
    发布/订阅模式中包含两种角色，分别是发布者和订阅者。订阅者可以订阅一个或若干个频道(channel),而发布者可以向指定的频道发送消息，所有订阅此频道的订阅者都会收到此消息。
    发布者发布消息的命令是publish，用法是publish channel message,
        redis> publish channel.1 hi
        (integer) 0
    publish命令的返回值表示接收到这条消息的订阅者数量。因为此时没有客户端订阅channel.1, 所以返回0。发出去的消息不会被持久化，也就是说当有客户端订阅channel.1后
只能收到后续发布到该频道的消息，之前发送的就收不到了。
    订阅频道的命令是subscribe,可以同时订阅多个频道，用法是subscribe channel [channel ...]
        redis a> subscribe channel.1
        reading messages... (press ctrl-c to quit)
        1) "subscribe"
        2) "channel.1"
        3) ! (integer) 1
    执行subscribe命令后客户端会进入订阅状态，处于此状态下客户端不能使用除subscri be/unsubscribe/psubscribe/punsubscribe这4个属于“发布/订阅”模
式的命令之外的命令,否则会报错。
    进入订阅状态后客户端可能收到三种类型的回复。每种类型的回复都包含3个值，
    第一个值是消息的类型，根据消息类型的不同，第二、三个值的含义也不同。消息类型可能的取值有:
      (1)subscribe.表示订阅成功的反馈信息。第二个值是订阅成功的频道名称，第三个值是当前客户端订阅的频道数量。
      (2)message.这个类型的回复是我们最关心的，它表示接收到的消息。第二个值表示产生消息的频道名称，第三个值是消息的内容。
      (3)unsubscribe。表示成功取消订阅某个频道。第二个值是对应的频道名称，第三个值是当前客户端订阅的频道数量，当此值为0时客户端会退出订阅状态，之后就可以
执行其他非“发布订阅”模式的命令了。

管道:
    客户端和redis使用tcp协议连接。不论是客户端向redis发送命令还是redis 向客户端返回命令的执行结果，都需要经过网络传输，这两个部分的总耗时称为往返
时延。根据网络性能不同，往返时延也不同，大致来说到本地回环地址(loopback address)的往返时延在数量级上相当于redis处理一条简单命令 (如lpush list 1 2
3)的时间。如果执行较多的命令，每个命令的往返时延累加起来对性能还是有一定影响的。
    redis的底层通信协议对管道(pipelining) 提供了支持。通过管道可以一次性发送多条命令并在执行完后-次性将结果返回，当组命令中每条命令都不依赖于之前命令的执
行结果时就可以将这组命令一起通过管道发出。管道通过减少客户端与redis的通信次数来实现降低往返时延累计值的目的，参考 : 管道.png。

rdb快照:
    save 900 1
    save 300 10
    save 60 10000
    save参数指定了快照条件，可以存在多个条件，条件之间是“或”的关系。如上所说，save 900 1的意思是在15分钟(900秒钟)内有至少一个键被更改则进行快照。如果想
要禁用自动快照，只需要将所有的save参数删除即可。
    redis默认会将快照文件存储在当前目录的dump.rdb文件中，可以通过配置dir和dbfilename两个参数分别指定快照文件的存储路径和文件名。
    快照的过程如下。
        (1) redis 使用fork函数复制- 份当前进程(父进程)的副本(子进程);
        (2)父进程继续接收并处理客户端发来的命令，而子进程开始将内存中的数据写入硬盘中的临时文件:
        (3)当子进程写入完所有数据后会用该临时文件替换旧的rdb文件，至此次快照操作完成。
    在执行fork的时候操作系统(类unix操作系统)会使用写时复制(copy-on-write)策略，即fork函数发生的刻父子进程共享同内存数据，当父进程要更改其中某片数
据时(如执行一个写命令),操作系统会将该片数据复制一份以保证子进程的数据不受影响，所以新的rdb文件存储的是执行fork一刻的内存数据。
    rdb文件是经过压缩(可以配置rdbcompression参数以禁用压缩节省cpu占用)的二进制格式，所以占用的空间会小于内存中的数据大小，更加利于传输。
    除了自动快照，还可以手动发送save或bgsave命令让redis执行快照，两个命令的区别在于，前者是由主进程进行快照操作，会阻塞住其他请求，后者会通过fork
子进程进行快照操作。
    redis启动后会读取rdb快照文件，将数据从硬盘载入到内存。根据数据量大小与结构和服务器性能不同，这个时间也不同。通常将一个记录千万个字符串类型键、大小为
1gb的快照文件载入到内存中需要花费20~30秒钟。

aof方式:
    默认情况redis没有开启aof (append only file)方式的持久化，可以通过修改配置开启:
        appendonly yes
    开启aof持久化后每执行一条会更改redis中的数据的命令，redis就会将该命令写入硬盘中的aof文件。aof文件的保存位置和rdb文件的位置相同，都是通过dir参
数设置的，默认的文件名是appendonly.aof,可以通过appendfilename参数修改: appendfilename appendonly.aof
    每当达到定条件时redis就会自动重写aof文件，这个条件可以在配置文件中设置:
        auto-aof- rewrite-percentage 100
        auto-aof-rewrite-min-size 64mb
    auto-aof-rewrite-percentage参数的意义是当目前的aof文件大小超过上一次重写时的aof文件大小的百分之多少时会再次进行重写，如果之前没有重写过，则以启动
时的aof文件大小为依据。
    auto-aof-rewrite-min-size 参数限制了允许重写的最小aof文件大小，通常在aof文件很小的情况下即使其中有很多冗余的命令我们也并不太关心。除了让redis自动
执行重写外，我们还可以主动使用bgrewriteaof命令手动执行aof重写。
    在启动时redis会逐个执行aof文件中的命令来将硬盘中的数据载入到内存中，载入的速度相较rdb会慢-些。
    需要注意的是虽然每次执行更改数据库内容的操作时，aof都会将命令记录在aof文件中，但是事实上，由于操作系统的缓存机制，数据并没有真正地写入硬盘，而是进入
了系统的硬盘缓存。在默认情况下系统每30秒会执行次同步 操作，以便将硬盘缓存中的内容真正地写入硬盘，在这30秒的过程中如果系统异常退出则会导致硬盘缓存中的数据丢
失。一般来讲启用aof持久化的应用都无法容忍这样的损失，这就需要redis在写入aof文件后主动要求系统将缓存内容同步到硬盘中。在redis中我们可以通过appendfsync
参数设置同步的时机:
        #appendfsync always
        appendfsync everysec(默认是每秒执行刷入磁盘)
        #appendfsync no
    默认情况下redis采用everysec规则，即每秒执行一次同步操作。
        always:表示每次执行写入都会执行同步，这是最安全也是最慢的方式。
        no : 表示不主动进行同步操作，而是完全交由操作系统来做(即每30秒-次)， 这是最快但最不安全的方式。
    一般情况下使用默认值everysec就足够了，既兼顾了性能又保证了安全。
    redis允许同时开启aof和rdb,既保证了数据安全又使得进行备份等操作十分容易。此时重新启动redis后redis会使用aof文件来恢复数据，因为aof方式的持久化可能丢失的数
据更少。

redis主从:
    为了避免单点故障，我们希望将数据库复制多个副本以部署在不同的服务器上，即使有一台服务器出现故障其他服务器依然可以继续提供服务。这就要求当一台服务
器上的数据库更新后，可以自动将更新的数据同步到其他服务器上，redis 提供了复制(replication)功能可以自动实现同步的过程。
    配置:
        同步后的数据库分为两类，-类是主数据库(master), 一类是从数据库(slave)。主数据库可以进行读写操作，当发生写操作时自动将数据同步给从数据库。而从数据库一般
是只读的，并接受主数据库同步过来的数据。一个主数据库可以拥有多个从数据库，而一个从数据库只能拥有一个主数据库;
    在redis中使用复制功能非常容易，只需要在从数据库的配置文件中加入slaveof 主数据库ip 主数据库端口 即可，主数据库无需进行任何配置(如果是在同一台机器需要修改port)。
    可以通过设置从数据库的配置文件中的slave-read-only为no以使从数据库可写，但是对从数据库的任何更改都不会同步给任何其他数据库，并且一旦主数据库中更新了对
应的数据就会覆盖从数据库中的改动。
    除了通过配置文件或命令行参数设置slaveof参数，还可以在运行时使用slaveof命令修改:
        redis> siaveof 127.0.0.1 6379
    如果该数据库已经是其他主数据库的从数据库了, slaveof命令会停止和原来数据库的同步转而和新数据库同步。还可以使用slaveof no one来使当前数据库停止接收其他
数据库的同步转成主数据库。
    原理:
        当一个从数据库启动后，会向主数据库发送sync命令，主数据库接收到sync命令后会开始在后台保存快照(即rdb持久化的过程)，并将保存期间接收到的命令缓存起
来。当快照完成后，redis会将快照文件和所有缓存的命令发送给从数据库。从数据库收到后，会载入快照文件并执行收到的缓存的命令。当主从数据库断开重连后会重新执行
上述操作，不支持断点续传。
    
redis的默认配置会接受来自任何地址发送来的请求，即在任何一个拥有公网ip的服务器上启动redis服务器，都可以被外界直接访问到。要更改这设置，在配置文件中修
改bind参数，如只允许本机应用连接redis,可以将bind参数改成:
    bind 127.0.0.1(多个ip用空格分开)
    
设置密码:
    通过配置文件中的requirepass参数为redis设置个密码。例如:
        requirepass 123456
    配置redis复制的时候如果主数据库设置了密码，需要在从数据库的配置文件中通过masterauth参数设置主数据库的密码，以使从数据库连接主数据库时自动使用auth命令认证。

命名命令
    redis支持在配置文件中将命令重命名，比如将flushall命令重命名成一个比较复杂的名字，以保证只有自己的应用可以使用该命令。就像这样:
        rename -command flushall oyfekmj vmwxq5a9c8usofuo369x0it2k
    如果希望直接禁用某个命令可以将命令重命名成空字符串 : rename- command flushall 理

管理redis常用命令:
    1. 耗时命令日志
       当一条命令执行时间超过限制时，Redis 会将该命令的执行时间等信息加入耗时命令日志(slow log)以供开发者查看。可以通过配置文件的slowlog-log-slower-than参数
设置这-限制，要注意单位是微秒(1 000000微秒相当于1秒)，默认值是10000。耗时命令日志存储在内存中，可以通过配置文件的slowlog -max-len参数来限制记录的条数。
    2.命令监控
      Redis提供了MONITOR命令来监控Redis执行的所有命令, redis-cli同样支持这个命令，这时Redis执行的任何命令都会在redis-cli中打印出来;
      MONITOR命令非常影响Redis的性能，-个客户端使用MONITOR命令会降低Redis将近一半的负载能力。所以MONITOR命令只适合用来调试和纠错。
































